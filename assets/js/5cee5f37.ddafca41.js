"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[7130],{24656:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"desktop_applications/Rust/Collections","title":"Collections","description":"---","source":"@site/docs/desktop_applications/02_Rust/10_Collections.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Collections","permalink":"/docs/desktop_applications/Rust/Collections","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/10_Collections.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Collections"},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/docs/desktop_applications/Rust/Error-handling"},"next":{"title":"Impl and Methods","permalink":"/docs/desktop_applications/Rust/Impl-and-methods"}}');var i=n(74848),a=n(28453);const l={title:"Collections"},r=void 0,c={},o=[{value:"An Introduction to Rust&#39;s Standard Collections",id:"an-introduction-to-rusts-standard-collections",level:3},{value:"<code>Vec&lt;T&gt;</code>: The Growable Array",id:"vect-the-growable-array",level:3},{value:"Key Features:",id:"key-features",level:4},{value:"Example:",id:"example",level:4},{value:"<code>String</code> &amp; <code>&amp;str</code>: The Text Types",id:"string--str-the-text-types",level:3},{value:"Example:",id:"example-1",level:4},{value:"<code>HashMap&lt;K, V&gt;</code>: The Key-Value Store",id:"hashmapk-v-the-key-value-store",level:3},{value:"Key Features:",id:"key-features-1",level:4},{value:"Example:",id:"example-2",level:4},{value:"Other Useful Collections",id:"other-useful-collections",level:3}];function h(e){const s={a:"a",annotation:"annotation",code:"code",h3:"h3",h4:"h4",hr:"hr",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mspace:"mspace",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h3,{id:"an-introduction-to-rusts-standard-collections",children:"An Introduction to Rust's Standard Collections"}),"\n",(0,i.jsx)(s.p,{children:"Rust's standard library provides a rich set of data structures for managing data, all designed with the language's core principles of performance and safety in mind. These collections are generic, meaning they can hold any type of data, and they're highly optimized."}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h3,{id:"vect-the-growable-array",children:[(0,i.jsx)(s.code,{children:"Vec<T>"}),": The Growable Array"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"Vec<T>"})," is a dynamic, growable array, a lot like ",(0,i.jsx)(s.code,{children:"std::vector"})," in C++. It's one of the most widely used collections in Rust. It stores values on the heap, so its size can change at runtime."]}),"\n",(0,i.jsx)(s.h4,{id:"key-features",children:"Key Features:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Contiguous Storage:"})," Elements are stored next to each other in memory, making access very fast."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Heap-allocated:"})," The data is stored on the heap, and the ",(0,i.jsx)(s.code,{children:"Vec"})," itself is a small pointer on the stack, which points to the data."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Growable:"})," You can add and remove elements. ",(0,i.jsx)(s.code,{children:"push()"})," will handle reallocation if needed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"example",children:"Example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'// Create a new, empty Vec that will hold i32 values.\nlet mut numbers: Vec<i32> = Vec::new();\n\n// Add elements to the Vec.\nnumbers.push(10);\nnumbers.push(20);\nnumbers.push(30);\n\n// You can also create a Vec with initial values using a macro.\nlet mut other_numbers = vec![1, 2, 3];\n\n// Accessing elements by index. This will panic if the index is out of bounds.\nlet third = numbers[2];\nprintln!("The third element is: {}", third);\n\n// A safer way to get an element is with the `.get()` method, which returns an Option.\nmatch numbers.get(10) {\n    Some(value) => println!("The value at index 10 is: {}", value),\n    None => println!("Index 10 is out of bounds."),\n}\n\n\n\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h3,{id:"string--str-the-text-types",children:[(0,i.jsx)(s.code,{children:"String"})," & ",(0,i.jsx)(s.code,{children:"&str"}),": The Text Types"]}),"\n",(0,i.jsx)(s.p,{children:"Working with text in Rust involves two main types, which can be a point of confusion for beginners."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"String"})}),": This is a heap-allocated, growable, and mutable UTF-8 encoded string. It's the equivalent of ",(0,i.jsx)(s.code,{children:"std::string"})," in C++. You use it when you need to own the data and potentially modify it."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.code,{children:"&str"})," (string slice)"]}),': This is an immutable view or "slice" into a ',(0,i.jsx)(s.code,{children:"String"})," or a string literal. It's a pointer to the data and its length. You can think of it like ",(0,i.jsx)(s.code,{children:"const char*"})," in C++, but safer and aware of its length. ",(0,i.jsx)(s.code,{children:"&str"})," is often used for function arguments."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"example-1",children:"Example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'// A mutable, heap-allocated String.\nlet mut s1 = String::from("hello");\n\n// A string slice, which is a view into the string literal.\nlet s2: &str = "world";\n\n// You can push characters or strings onto a String.\ns1.push_str(", ");\ns1.push_str(s2);\ns1.push(\'!\');\n\nprintln!("{}", s1); // Prints "hello, world!"\n\n// String slices can be created from Strings.\nlet slice = &s1[0..5]; // This creates a slice "hello".\nprintln!("A slice: {}", slice);\n\n// Note that you cannot use an index to access a character directly,\n// as a single character might take up more than one byte in UTF-8.\n\n\n\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h3,{id:"hashmapk-v-the-key-value-store",children:[(0,i.jsx)(s.code,{children:"HashMap<K, V>"}),": The Key-Value Store"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"HashMap<K, V>"})," is a collection that stores data as key-value pairs, similar to ",(0,i.jsx)(s.code,{children:"std::unordered_map"})," in C++. It provides an efficient way to look up a value based on its key."]}),"\n",(0,i.jsx)(s.h4,{id:"key-features-1",children:"Key Features:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Key-Value Pairs:"})," Stores data in a ",(0,i.jsx)(s.code,{children:"(key, value)"})," format."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Efficient Lookups:"})," Provides average ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mn,{children:"1"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord",children:"1"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity for insertion and retrieval."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Hashing:"})," The key type ",(0,i.jsx)(s.code,{children:"K"})," must implement the ",(0,i.jsx)(s.code,{children:"Hash"})," trait so the ",(0,i.jsx)(s.code,{children:"HashMap"})," can determine where to store the data. It also needs to implement the ",(0,i.jsx)(s.code,{children:"Eq"})," trait for comparison."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"example-2",children:"Example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'use std::collections::HashMap;\n\n// Create a new HashMap. The compiler will infer the types.\nlet mut scores = HashMap::new();\n\n// Insert key-value pairs.\nscores.insert(String::from("Blue"), 10);\nscores.insert(String::from("Yellow"), 50);\n\n// Get a value from the HashMap. This returns an Option<&V>.\nlet team_name = String::from("Blue");\nlet score = scores.get(&team_name);\n\nmatch score {\n    Some(value) => println!("The blue team\'s score is: {}", value),\n    None => println!("No score found for that team."),\n}\n\n// Iterate over the HashMap\'s key-value pairs.\nfor (key, value) in &scores {\n    println!("{}: {}", key, value);\n}\n\n\n\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h3,{id:"other-useful-collections",children:"Other Useful Collections"}),"\n",(0,i.jsx)(s.p,{children:"Beyond the core collections, Rust's standard library offers several others for more specific use cases. Here's a brief mention of them with links to their official documentation for further exploration."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"HashSet<T>"})}),": A collection of unique values, similar to ",(0,i.jsx)(s.code,{children:"std::unordered_set"})," in C++. It offers fast, average ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mn,{children:"1"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord",children:"1"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})})]})," time complexity for insertion, deletion, and checking for the presence of an item."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsxs)(s.a,{href:"https://doc.rust-lang.org/std/collections/struct.HashSet.html",children:["Official ",(0,i.jsx)(s.code,{children:"HashSet"})," Docs"]})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"BTreeMap<K, V>"})}),": A map that stores key-value pairs in a sorted order, comparable to ",(0,i.jsx)(s.code,{children:"std::map"})," in C++. It has a logarithmic ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mspace,{linebreak:"newline"}),(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"n"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\\\log n)"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("})]}),(0,i.jsx)(s.span,{className:"mspace newline"}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})]})]})," time complexity for operations but guarantees a consistent, sorted iteration order."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsxs)(s.a,{href:"https://doc.rust-lang.org/std/collections/struct.BTreeMap.html",children:["Official ",(0,i.jsx)(s.code,{children:"BTreeMap"})," Docs"]})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"BTreeSet<T>"})}),": A collection of unique, sorted values, similar to ",(0,i.jsx)(s.code,{children:"std::set"})," in C++. It also provides logarithmic ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"O"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mspace,{linebreak:"newline"}),(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mi,{children:"o"}),(0,i.jsx)(s.mi,{children:"g"}),(0,i.jsx)(s.mi,{children:"n"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(\\\\log n)"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(s.span,{className:"mopen",children:"("})]}),(0,i.jsx)(s.span,{className:"mspace newline"}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"o"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(s.span,{className:"mclose",children:")"})]})]})]})," time complexity and guarantees sorted iteration."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsxs)(s.a,{href:"https://doc.rust-lang.org/std/collections/struct.BTreeSet.html",children:["Official ",(0,i.jsx)(s.code,{children:"BTreeSet"})," Docs"]})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"VecDeque<T>"})}),": A double-ended queue, which is a growable array optimized for efficient pushes and pops from both the front and the back."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsxs)(s.a,{href:"https://doc.rust-lang.org/std/collections/struct.VecDeque.html",children:["Official ",(0,i.jsx)(s.code,{children:"VecDeque"})," Docs"]})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"LinkedList<T>"})}),": A classic doubly-linked list. While a ",(0,i.jsx)(s.code,{children:"VecDeque"})," is often a better choice, a ",(0,i.jsx)(s.code,{children:"LinkedList"})," can be more efficient for frequent insertions and deletions at arbitrary positions."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsxs)(s.a,{href:"https://doc.rust-lang.org/std/collections/struct.LinkedList.html",children:["Official ",(0,i.jsx)(s.code,{children:"LinkedList"})," Docs"]})}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>r});var t=n(96540);const i={},a=t.createContext(i);function l(e){const s=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);