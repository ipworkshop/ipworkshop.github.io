"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[9707],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},41425:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"desktop_applications/Rust/Functions-and-control-flow","title":"Control Flow and Functions","description":"We\'ll learn how to make decisions based on conditions, repeat actions, and organize our code into reusable blocks. By the end, we\'ll even build a game\\\\!","source":"@site/docs/desktop_applications/02_Rust/04_Functions-and-control-flow.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Functions-and-control-flow","permalink":"/docs/desktop_applications/Rust/Functions-and-control-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/04_Functions-and-control-flow.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Control Flow and Functions"},"sidebar":"tutorialSidebar","previous":{"title":"Variables and data types","permalink":"/docs/desktop_applications/Rust/Variables-and-data-types"},"next":{"title":"Ownership, Borrowing, and Slices in Rust","permalink":"/docs/desktop_applications/Rust/Ownership-and-borrowing"}}');var s=i(74848),o=i(28453);const r={title:"Control Flow and Functions"},l=void 0,a={},c=[{value:"1. Conditional Execution: <code>if</code> Statements",id:"1-conditional-execution-if-statements",level:3},{value:"<strong>Basic <code>if</code>, <code>else if</code>, <code>else</code>:</strong>",id:"basic-if-else-if-else",level:4},{value:"<strong><code>if</code> as an Expression:</strong>",id:"if-as-an-expression",level:4},{value:"2. Iterative Control Structures",id:"2-iterative-control-structures",level:3},{value:"<strong><code>loop</code> (Infinite Loop with <code>break</code>):</strong>",id:"loop-infinite-loop-with-break",level:4},{value:"<strong><code>while</code> Loop:</strong>",id:"while-loop",level:4},{value:"<strong><code>for</code> Loop (Iterating over Collections):</strong>",id:"for-loop-iterating-over-collections",level:4},{value:"3. Defining and Utilizing Functions",id:"3-defining-and-utilizing-functions",level:3},{value:"<strong>Basic Function Syntax:</strong>",id:"basic-function-syntax",level:4}];function d(e){const n={code:"code",em:"em",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"We'll learn how to make decisions based on conditions, repeat actions, and organize our code into reusable blocks. By the end, we'll even build a game!"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"1-conditional-execution-if-statements",children:["1. Conditional Execution: ",(0,s.jsx)(n.code,{children:"if"})," Statements"]}),"\n",(0,s.jsxs)(n.p,{children:["Just like in other programming languages, ",(0,s.jsx)(n.code,{children:"if"})," statements in Rust let your program execute different code blocks based on whether a condition is true or false."]}),"\n",(0,s.jsx)(n.h4,{id:"basic-if-else-if-else",children:(0,s.jsxs)(n.strong,{children:["Basic ",(0,s.jsx)(n.code,{children:"if"}),", ",(0,s.jsx)(n.code,{children:"else if"}),", ",(0,s.jsx)(n.code,{children:"else"}),":"]})}),"\n",(0,s.jsx)(n.p,{children:"You'll find this structure very familiar:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let number = 7;\n\n    if number < 5 { // If this condition is true\n        println!("Condition was true: number is less than 5");\n    } else if number == 5 { // Otherwise, if this condition is true\n        println!("Condition was true: number is exactly 5");\n    } else { // If none of the above conditions are true\n        println!("Condition was false: number is greater than 5");\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Conditions Must Be ",(0,s.jsx)(n.code,{children:"bool"}),":"]})," In Rust, the condition inside an ",(0,s.jsx)(n.code,{children:"if"})," statement ",(0,s.jsx)(n.em,{children:"must"})," evaluate to a ",(0,s.jsx)(n.strong,{children:"boolean"})," (",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"}),"). You can't just use a number like in some other languages.","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// This would be an ERROR: `if number` is not allowed in Rust\n// if number {\n//     println!("Number was something!");\n// }\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"if-as-an-expression",children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"if"})," as an Expression:"]})}),"\n",(0,s.jsxs)(n.p,{children:["A cool feature in Rust is that ",(0,s.jsx)(n.code,{children:"if"})," statements are ",(0,s.jsx)(n.strong,{children:"expressions"}),", meaning they can return a value. This is super handy for assigning values conditionally."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let condition = true;\n    let number = if condition { // \'if\' expression returns a value\n        5 // This value is returned if \'condition\' is true\n    } else {\n        6 // This value is returned if \'condition\' is false\n    }; // Note the semicolon here, as it\'s a statement assigning a value\n\n    println!("The value of number is: {}", number); // Output: The value of number is: 5\n\n    let message = if number > 5 {\n        "Number is greater than 5"\n    } else {\n        "Number is 5 or less"\n    }; // Both branches must return the SAME TYPE!\n\n    println!("Message: {}", message);\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," All branches of an ",(0,s.jsx)(n.code,{children:"if"})," expression ",(0,s.jsx)(n.strong,{children:"must return the same type"}),". If one branch returns an integer and another returns a string, Rust won't compile because it can't determine the final type of the variable."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"2-iterative-control-structures",children:"2. Iterative Control Structures"}),"\n",(0,s.jsx)(n.p,{children:"Repeating actions is a fundamental part of programming. Rust provides several ways to create loops."}),"\n",(0,s.jsx)(n.h4,{id:"loop-infinite-loop-with-break",children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"loop"})," (Infinite Loop with ",(0,s.jsx)(n.code,{children:"break"}),"):"]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"loop"})," keyword creates an infinite loop. You'll typically use ",(0,s.jsx)(n.code,{children:"break"})," to exit it based on a condition, and ",(0,s.jsx)(n.code,{children:"continue"})," to skip to the next iteration."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let mut counter = 0;\n\n    let result = loop { // \'loop\' can also return a value!\n        counter += 1;\n        println!("Loop count: {}", counter);\n\n        if counter == 10 {\n            break counter * 2; // Break the loop and return this value\n        }\n    }; // Semicolon here, as it\'s an expression\n\n    println!("Loop finished. Result: {}", result); // Output: Loop finished. Result: 20\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"while-loop",children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"while"})," Loop:"]})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"while"})," loop executes a block of code repeatedly as long as a specified condition remains true."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!("{}!", number);\n        number -= 1; // Decrement number\n    }\n    println!("LIFTOFF!!!");\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"for-loop-iterating-over-collections",children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"for"})," Loop (Iterating over Collections):"]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"for"})," loop is the most common loop in Rust. It's used to iterate over elements in a collection (like arrays, vectors, or ranges). This is often safer and more concise than ",(0,s.jsx)(n.code,{children:"while"})," loops for iterating."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Iterating over a Range:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    // Iterate from 1 up to (but not including) 5\n    for number in 1..5 {\n        println!("Number in range: {}", number);\n    }\n    // Iterate from 1 up to AND including 5\n    for number in 1..=5 {\n        println!("Number in range (inclusive): {}", number);\n    }\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Iterating over an Array/Vector:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a.iter() { // .iter() creates an iterator over the elements\n        println!("The value is: {}", element);\n    }\n\n    // You can also iterate with an index if needed (less common in idiomatic Rust)\n    for (index, element) in a.iter().enumerate() {\n        println!("Element at index {}: {}", index, element);\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"3-defining-and-utilizing-functions",children:"3. Defining and Utilizing Functions"}),"\n",(0,s.jsx)(n.p,{children:"Functions are blocks of code that perform a specific task and can be reused."}),"\n",(0,s.jsx)(n.h4,{id:"basic-function-syntax",children:(0,s.jsx)(n.strong,{children:"Basic Function Syntax:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Functions are declared using the ",(0,s.jsx)(n.code,{children:"fn"})," keyword."]}),"\n",(0,s.jsx)(n.li,{children:"Parameters are type-annotated."}),"\n",(0,s.jsxs)(n.li,{children:["The return type is specified after an arrow ",(0,s.jsx)(n.code,{children:"->"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The last expression in a function (without a semicolon) is implicitly returned. You can also use the ",(0,s.jsx)(n.code,{children:"return"})," keyword explicitly."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// A function that doesn\'t take parameters and doesn\'t return a value\nfn greet() {\n    println!("Hello from the greet function!");\n}\n\n// A function that takes parameters and returns a value\nfn add_numbers(x: i32, y: i32) -> i32 { // Takes two i32s, returns an i32\n    x + y // This is an expression, implicitly returned\n}\n\n// A function with an explicit return\nfn subtract_numbers(a: i32, b: i32) -> i32 {\n    return a - b; // Explicit return\n}\n\nfn main() {\n    greet(); // Call the greet function\n\n    let sum = add_numbers(5, 7); // Call add_numbers and store the result\n    println!("The sum is: {}", sum); // Output: The sum is: 12\n\n    let difference = subtract_numbers(10, 3);\n    println!("The difference is: {}", difference); // Output: The difference is: 7\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Well, you have all the required knowladge to solve the first exercise. It is time to practice!"})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);