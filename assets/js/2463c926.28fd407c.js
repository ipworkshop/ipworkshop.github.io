"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[5380],{297:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"desktop_applications/Networking/Async-await","title":"Async and Await","description":"Asynchronous Programming with async and await","source":"@site/docs/desktop_applications/05_Networking/01_Async-await.md","sourceDirName":"desktop_applications/05_Networking","slug":"/desktop_applications/Networking/Async-await","permalink":"/docs/desktop_applications/Networking/Async-await","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/05_Networking/01_Async-await.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Async and Await"},"sidebar":"tutorialSidebar","previous":{"title":"Binding-to-ui","permalink":"/docs/desktop_applications/Data/Binding-to-ui"},"next":{"title":"Http Requests with reqwest","permalink":"/docs/desktop_applications/Networking/Http-requests-with-reqwest"}}');var s=t(4848),o=t(8453);const a={title:"Async and Await"},r=void 0,c={},d=[{value:"Asynchronous Programming with <code>async</code> and <code>await</code>",id:"asynchronous-programming-with-async-and-await",level:3},{value:"The <code>async</code> Keyword: Creating a <code>Future</code>",id:"the-async-keyword-creating-a-future",level:3},{value:"The <code>await</code> Keyword and the Runtime",id:"the-await-keyword-and-the-runtime",level:3},{value:"Concurrency with <code>await</code>: <code>join!</code> and <code>select!</code>",id:"concurrency-with-await-join-and-select",level:3},{value:"The &quot;No Await&quot; Pitfall: Dropping a <code>Future</code>",id:"the-no-await-pitfall-dropping-a-future",level:3}];function l(e){const n={code:"code",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h3,{id:"asynchronous-programming-with-async-and-await",children:["Asynchronous Programming with ",(0,s.jsx)(n.code,{children:"async"})," and ",(0,s.jsx)(n.code,{children:"await"})]}),"\n",(0,s.jsxs)(n.p,{children:["Asynchronous programming is a way for your program to perform tasks without waiting for a blocking operation (like a slow network request or reading a large file) to finish. Instead of blocking, your program can start another task while it waits, maximizing efficiency. In Rust, this is achieved using the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"async"})})," and ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"await"})})," keywords, which work together with an asynchronous runtime to manage these non-blocking operations."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"the-async-keyword-creating-a-future",children:["The ",(0,s.jsx)(n.code,{children:"async"})," Keyword: Creating a ",(0,s.jsx)(n.code,{children:"Future"})]}),"\n",(0,s.jsxs)(n.p,{children:["When you mark a function with the ",(0,s.jsx)(n.code,{children:"async"})," keyword, you're telling the compiler that this function contains an asynchronous operation. Critically, an ",(0,s.jsx)(n.code,{children:"async"})," function does not run its code immediately when called. Instead, it returns a special type called a ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Future"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Think of a ",(0,s.jsx)(n.code,{children:"Future"}),' as a "promise" or a "recipe" for an upcoming value. It\'s an inert object that describes what work needs to be done. The work described in the ',(0,s.jsx)(n.code,{children:"async"})," function won't start until this ",(0,s.jsx)(n.code,{children:"Future"})," is actively executed by a runtime."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'async fn my_async_task() -> String {\n    // This code will only run when the Future is awaited.\n    "Task finished".to_string()\n}\n\nfn main() {\n    // Calling the async function returns a Future, but nothing runs.\n    let future = my_async_task();\n\n    // The program would end here without executing my_async_task().\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This example shows that just calling ",(0,s.jsx)(n.code,{children:"my_async_task()"})," by itself does nothing. The ",(0,s.jsx)(n.code,{children:"Future"})," is created and immediately dropped because it's never told to run."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"the-await-keyword-and-the-runtime",children:["The ",(0,s.jsx)(n.code,{children:"await"})," Keyword and the Runtime"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"await"})})," keyword is the key to running a ",(0,s.jsx)(n.code,{children:"Future"}),'. It tells the program to "execute this ',(0,s.jsx)(n.code,{children:"Future"})," and give me its value when it's ready.\" When an ",(0,s.jsx)(n.code,{children:"await"})," call is made, the current task pauses, yielding control to an asynchronous runtime. The runtime then looks for other tasks to run that are ready to make progress."]}),"\n",(0,s.jsxs)(n.p,{children:["For this system to work, your application needs an ",(0,s.jsx)(n.strong,{children:"asynchronous runtime"}),". This is the scheduler that manages all the ",(0,s.jsx)(n.code,{children:"Future"}),"s, decides when they should run, and wakes them up when a blocking operation (like a network request) completes. ",(0,s.jsx)(n.strong,{children:"Tokio"})," is the most popular runtime for Rust."]}),"\n",(0,s.jsxs)(n.p,{children:["To use Tokio, you must first add it to your ",(0,s.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\ntokio = { version = "1", features = ["full"] }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Then, you can use the ",(0,s.jsx)(n.code,{children:"#[tokio::main]"})," macro to set up the runtime and make your ",(0,s.jsx)(n.code,{children:"main"})," function an async entry point."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() {\n    println!("Start of program.");\n\n    // The program pauses here for 2 seconds without blocking the thread.\n    sleep(Duration::from_secs(2)).await;\n\n    println!("End of program after waiting.");\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"concurrency-with-await-join-and-select",children:["Concurrency with ",(0,s.jsx)(n.code,{children:"await"}),": ",(0,s.jsx)(n.code,{children:"join!"})," and ",(0,s.jsx)(n.code,{children:"select!"})]}),"\n",(0,s.jsxs)(n.p,{children:["The real power of ",(0,s.jsx)(n.code,{children:"async"})," and ",(0,s.jsx)(n.code,{children:"await"})," is the ability to run multiple tasks concurrently. By starting several ",(0,s.jsx)(n.code,{children:"Future"}),"s and then awaiting them, your program's runtime will manage them all efficiently. The ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"tokio::join!"})})," macro is perfect for this, as it waits for all given ",(0,s.jsx)(n.code,{children:"Future"}),"s to complete."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use tokio::time::{sleep, Duration};\nuse tokio::join;\n\nasync fn fetch_user_data() -> String {\n    sleep(Duration::from_secs(3)).await;\n    println!("User data fetched after 3s.");\n    "User".to_string()\n}\n\nasync fn fetch_product_data() -> String {\n    sleep(Duration::from_secs(1)).await;\n    println!("Product data fetched after 1s.");\n    "Product".to_string()\n}\n\n#[tokio::main]\nasync fn main() {\n    println!("Fetching data concurrently...");\n\n    // These two futures are started at the same time and run together.\n    let (user_data, product_data) = join!(fetch_user_data(), fetch_product_data());\n\n    println!("Total execution time is ~3s, not 4s.");\n    println!("Result 1: {}", user_data);\n    println!("Result 2: {}", product_data);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the total execution time is approximately 3 seconds (the duration of the longest task), not the sum of both tasks, because they run concurrently. The ",(0,s.jsx)(n.code,{children:"join!"})," macro waits for both futures to complete before moving on. The ",(0,s.jsx)(n.code,{children:"tokio::select!"})," macro is similar, but it completes as soon as one of the futures finishes."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"the-no-await-pitfall-dropping-a-future",children:['The "No Await" Pitfall: Dropping a ',(0,s.jsx)(n.code,{children:"Future"})]}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned earlier, simply calling an ",(0,s.jsx)(n.code,{children:"async"})," function and not using ",(0,s.jsx)(n.code,{children:"await"})," means the ",(0,s.jsx)(n.code,{children:"Future"})," is never executed. It's created and immediately dropped at the end of the line."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use tokio::time::{sleep, Duration};\n\nasync fn my_task() {\n    sleep(Duration::from_secs(1)).await;\n    println!("This line will never be printed.");\n}\n\n#[tokio::main]\nasync fn main() {\n    println!("Starting program.");\n\n    // We call the async function, but we don\'t await its Future.\n    // The Future is created but immediately dropped.\n    my_task();\n\n    println!("Finished program.");\n    // The program ends immediately, and \'my_task\' never runs.\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is a common mistake for newcomers to async Rust. You must always ",(0,s.jsx)(n.code,{children:"await"})," a ",(0,s.jsx)(n.code,{children:"Future"})," or pass it to a runtime scheduler (e.g., with a function like ",(0,s.jsx)(n.code,{children:"tokio::spawn"}),") for its code to execute."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);