"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[1127],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(96540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},45458:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"desktop_applications/Rust/Impl-and-methods","title":"Impl and Methods","description":"Associated Functions (Methods) to structs using impl:","source":"@site/docs/desktop_applications/02_Rust/11_Impl-and-methods.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Impl-and-methods","permalink":"/docs/desktop_applications/Rust/Impl-and-methods","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/11_Impl-and-methods.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"title":"Impl and Methods"},"sidebar":"tutorialSidebar","previous":{"title":"Collections","permalink":"/docs/desktop_applications/Rust/Collections"},"next":{"title":"Module Organization","permalink":"/docs/desktop_applications/Rust/Module-organization"}}');var o=n(74848),i=n(28453);const a={title:"Impl and Methods"},c=void 0,r={},l=[{value:"<strong>Associated Functions (Methods) to <code>structs</code> using <code>impl</code>:</strong>",id:"associated-functions-methods-to-structs-using-impl",level:4}];function d(e){const t={code:"code",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h4,{id:"associated-functions-methods-to-structs-using-impl",children:(0,o.jsxs)(t.strong,{children:["Associated Functions (Methods) to ",(0,o.jsx)(t.code,{children:"structs"})," using ",(0,o.jsx)(t.code,{children:"impl"}),":"]})}),"\n",(0,o.jsxs)(t.p,{children:["You can define functions that belong to a ",(0,o.jsx)(t.code,{children:"struct"})," using an ",(0,o.jsx)(t.code,{children:"impl"})," (implementation) block. These are often called ",(0,o.jsx)(t.strong,{children:"methods"})," if their first parameter is ",(0,o.jsx)(t.code,{children:"self"})," (a reference to the instance of the struct)."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:'struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\n// Implement methods for the Rectangle struct\nimpl Rectangle {\n    // A method that takes an immutable reference to self\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n    // A method that takes a mutable reference to self\n    fn scale(&mut self, factor: u32) {\n        self.width *= factor;\n        self.height *= factor;\n    }\n\n    // An associated function (not a method, doesn\'t take self)\n    // Often used as constructors (like \'new\' in other languages)\n    fn square(size: u32) -> Rectangle {\n        Rectangle {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n    println!("The area of the rectangle is {} square pixels.", rect1.area()); // Call method\n\n    let mut rect2 = Rectangle { width: 10, height: 20 };\n    rect2.scale(2); // Call mutable method\n    println!("Scaled rectangle: width={}, height={}", rect2.width, rect2.height);\n\n    let sq = Rectangle::square(25); // Call associated function using ::\n    println!("Square area: {}", sq.area());\n}\n'})})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);