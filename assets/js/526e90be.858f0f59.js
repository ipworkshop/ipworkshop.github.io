"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[33],{3146:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"desktop_applications/Rust/Structs-and-enums","title":"Structs and Enums","description":"Structuring Data with structs","source":"@site/docs/desktop_applications/02_Rust/08_Structs-and-enums.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Structs-and-enums","permalink":"/docs/desktop_applications/Rust/Structs-and-enums","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/08_Structs-and-enums.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Structs and Enums"},"sidebar":"tutorialSidebar","previous":{"title":"Pattern Matching","permalink":"/docs/desktop_applications/Rust/Pattern-matching"},"next":{"title":"Error Handling","permalink":"/docs/desktop_applications/Rust/Error-handling"}}');var i=t(4848),r=t(8453);const a={title:"Structs and Enums"},o=void 0,l={},c=[{value:"Structuring Data with <code>struct</code>s",id:"structuring-data-with-structs",level:3},{value:"<strong>Defining a <code>struct</code>:</strong>",id:"defining-a-struct",level:4},{value:"<strong>Tuple Structs:</strong>",id:"tuple-structs",level:4},{value:"<strong>Unit-Like Structs:</strong>",id:"unit-like-structs",level:4},{value:"<strong>Printing Structs with <code>Debug</code> Trait:</strong>",id:"printing-structs-with-debug-trait",level:4},{value:"Modeling Data with <code>enum</code>s",id:"modeling-data-with-enums",level:3},{value:"<strong>Simple <code>enum</code>s:</strong>",id:"simple-enums",level:4},{value:"<strong><code>enum</code>s with Associated Data:</strong>",id:"enums-with-associated-data",level:4},{value:"<strong>The <code>Option&lt;T&gt;</code> Enum (Handling Absence of a Value):</strong>",id:"the-optiont-enum-handling-absence-of-a-value",level:4},{value:"<strong>The <code>Result&lt;T, E&gt;</code> Enum (Handling Recoverable Errors):</strong>",id:"the-resultt-e-enum-handling-recoverable-errors",level:4}];function u(e){const n={code:"code",em:"em",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h3,{id:"structuring-data-with-structs",children:["Structuring Data with ",(0,i.jsx)(n.code,{children:"struct"}),"s"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"struct"}),'s (short for "structures") allow you to create custom data types by grouping related data together. They are similar to classes in object-oriented languages or objects/dictionaries in JavaScript/Python, but without built-in methods initially.']}),"\n",(0,i.jsx)(n.h4,{id:"defining-a-struct",children:(0,i.jsxs)(n.strong,{children:["Defining a ",(0,i.jsx)(n.code,{children:"struct"}),":"]})}),"\n",(0,i.jsxs)(n.p,{children:["You define a ",(0,i.jsx)(n.code,{children:"struct"})," using the ",(0,i.jsx)(n.code,{children:"struct"})," keyword, followed by its name (typically ",(0,i.jsx)(n.code,{children:"PascalCase"}),"), and then curly braces containing its fields (each with a name and a type)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Define a struct named \'User\'\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    // Creating an instance of a struct\n    let user1 = User { // Order of fields doesn\'t matter\n        active: true,\n        username: String::from("alice123"),\n        email: String::from("alice@example.com"),\n        sign_in_count: 1,\n    };\n\n    // Accessing values using dot notation\n    println!("User 1 Name: {}", user1.username);\n    println!("User 1 Email: {}", user1.email);\n\n    // To modify a field, the struct instance itself must be mutable\n    let mut user2 = User {\n        active: false,\n        username: String::from("bob456"),\n        email: String::from("bob@example.com"),\n        sign_in_count: 5,\n    };\n\n    user2.email = String::from("new_bob@example.com"); // This is allowed\n    println!("User 2 New Email: {}", user2.email);\n\n    // You can also create new instances from existing ones using the struct update syntax\n    let user3 = User {\n        email: String::from("charlie@example.com"),\n        username: String::from("charlie789"),\n        ..user1 // Fills remaining fields from user1 (active, sign_in_count)\n    };\n    println!("User 3 Name: {}, Active: {}", user3.username, user3.active);\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"tuple-structs",children:(0,i.jsx)(n.strong,{children:"Tuple Structs:"})}),"\n",(0,i.jsx)(n.p,{children:"Tuple structs are like tuples but have a name. They are useful when you want to give a name to a tuple but don't need named fields."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'struct Color(i32, i32, i32); // RGB values\nstruct Point(i32, i32, i32); // X, Y, Z coordinates\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n\n    println!("Black RGB: ({}, {}, {})", black.0, black.1, black.2);\n    // Note: black.0 is the first element, black.1 the second, etc.\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"unit-like-structs",children:(0,i.jsx)(n.strong,{children:"Unit-Like Structs:"})}),"\n",(0,i.jsx)(n.p,{children:"These are useful when you need to implement a trait on some type but don't have any data that you want to store inside the type itself."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct AlwaysEqual; // No fields\n\nfn main() {\n    let subject = AlwaysEqual;\n    // You can use it as a type, but it holds no data.\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"printing-structs-with-debug-trait",children:(0,i.jsxs)(n.strong,{children:["Printing Structs with ",(0,i.jsx)(n.code,{children:"Debug"})," Trait:"]})}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"println!"})," cannot directly print structs in a readable format. You need to derive the ",(0,i.jsx)(n.code,{children:"Debug"})," trait for your struct using ",(0,i.jsx)(n.code,{children:"#[derive(Debug)]"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug)] // Add this line above your struct definition\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from("alice123"),\n        email: String::from("alice@example.com"),\n        sign_in_count: 1,\n    };\n\n    println!("User 1: {:?}", user1); // Use {:?} for debug printing\n    println!("User 1 (pretty print): {:#?}", user1); // Use {:#?} for pretty printing\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"modeling-data-with-enums",children:["Modeling Data with ",(0,i.jsx)(n.code,{children:"enum"}),"s"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enum"}),"s (enumerations) allow you to define a type by enumerating its possible variants. In Rust, ",(0,i.jsx)(n.code,{children:"enum"}),'s are much more powerful than in many other languages; they are "sum types," meaning a value of an ',(0,i.jsx)(n.code,{children:"enum"})," can be ",(0,i.jsx)(n.em,{children:"one of"})," a set of defined possibilities."]}),"\n",(0,i.jsx)(n.h4,{id:"simple-enums",children:(0,i.jsxs)(n.strong,{children:["Simple ",(0,i.jsx)(n.code,{children:"enum"}),"s:"]})}),"\n",(0,i.jsxs)(n.p,{children:["You've already seen ",(0,i.jsx)(n.code,{children:"Ordering"})," in the guessing game, which is a simple enum."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'enum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n\nfn main() {\n    let current_light = TrafficLight::Red;\n\n    match current_light { // Often used with \'match\' for exhaustive handling\n        TrafficLight::Red => println!("Stop!"),\n        TrafficLight::Yellow => println!("Prepare to stop!"),\n        TrafficLight::Green => println!("Go!"),\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"enums-with-associated-data",children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"enum"}),"s with Associated Data:"]})}),"\n",(0,i.jsx)(n.p,{children:"This is where Rust's enums become extremely powerful. Each variant of an enum can hold its own specific data."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'enum Message {\n    Quit, // No data\n    Move { x: i32, y: i32 }, // Anonymous struct-like data\n    Write(String), // Single String data\n    ChangeColor(i32, i32, i32), // Tuple-like data (RGB values)\n}\n\nfn main() {\n    let m1 = Message::Quit;\n    let m2 = Message::Move { x: 10, y: 20 };\n    let m3 = Message::Write(String::from("hello"));\n    let m4 = Message::ChangeColor(255, 0, 128);\n\n    // Using match to destructure and handle different enum variants\n    match m2 {\n        Message::Quit => println!("The Quit message has no data."),\n        Message::Move { x, y } => println!("Move to x: {}, y: {}", x, y),\n        Message::Write(text) => println!("Write message: {}", text),\n        Message::ChangeColor(r, g, b) => println!("Change color to R:{}, G:{}, B:{}", r, g, b),\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"the-optiont-enum-handling-absence-of-a-value",children:(0,i.jsxs)(n.strong,{children:["The ",(0,i.jsx)(n.code,{children:"Option<T>"})," Enum (Handling Absence of a Value):"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Option<T>"})," is a standard library enum that represents a value that might or might not be present. It's Rust's way of handling null/nil without null pointer exceptions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'enum Option<T> { // Conceptual definition\n    None,    // Represents no value\n    Some(T), // Represents a value of type T\n}\n\nfn main() {\n    let some_number = Some(5); // A value is present\n    let no_number: Option<i32> = None; // No value is present\n\n    // You MUST use match (or other Option methods) to safely get the value out\n    match some_number {\n        Some(value) => println!("We have a number: {}", value),\n        None => println!("No number here."),\n    }\n\n    match no_number {\n        Some(value) => println!("We have a number: {}", value),\n        None => println!("No number here."),\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"the-resultt-e-enum-handling-recoverable-errors",children:(0,i.jsxs)(n.strong,{children:["The ",(0,i.jsx)(n.code,{children:"Result<T, E>"})," Enum (Handling Recoverable Errors):"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Result<T, E>"})," is another fundamental enum for handling operations that can succeed or fail. You saw it with ",(0,i.jsx)(n.code,{children:"read_line()"})," in Lesson 1."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'enum Result<T, E> { // Conceptual definition\n    Ok(T),  // Represents success, holding a value of type T\n    Err(E), // Represents failure, holding an error of type E\n}\n\nfn main() {\n    // Example: A function that might fail\n    fn divide(numerator: f64, denominator: f64) -> Result<f64, String> {\n        if denominator == 0.0 {\n            Err(String::from("Cannot divide by zero!"))\n        } else {\n            Ok(numerator / denominator)\n        }\n    }\n\n    let division_result = divide(10.0, 2.0);\n    match division_result {\n        Ok(value) => println!("Division successful: {}", value),\n        Err(error) => println!("Division failed: {}", error),\n    }\n\n    let division_by_zero = divide(10.0, 0.0);\n    match division_by_zero {\n        Ok(value) => println!("Division successful: {}", value),\n        Err(error) => println!("Division failed: {}", error),\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Key takeaway for ",(0,i.jsx)(n.code,{children:"Option"})," and ",(0,i.jsx)(n.code,{children:"Result"}),":"]})," Rust forces you to explicitly handle the possibility of a value being absent or an operation failing, leading to more robust code."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);