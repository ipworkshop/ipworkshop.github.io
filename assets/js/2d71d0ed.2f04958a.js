"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[5534],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}},48464:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"embedded/index","title":"Introduction","description":"Prerequisites","source":"@site/docs/embedded/index.md","sourceDirName":"embedded","slug":"/embedded/","permalink":"/docs/embedded/","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/embedded/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"PWM Control with CTIMER on the FRDM\u2013MCXN947 Board","permalink":"/docs/autonomous_cars/programming/drivers/"},"next":{"title":"Intorduction","permalink":"/docs/desktop_applications/"}}');var o=t(74848),s=t(28453);const i={},a="Introduction",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Customize your kernel",id:"customize-your-kernel",level:2},{value:"Print Counter Capsule",id:"print-counter-capsule",level:2},{value:"The simple way",id:"the-simple-way",level:3},{value:"The Tock way",id:"the-tock-way",level:3},{value:"The role of a Scheduler",id:"the-role-of-a-scheduler",level:2},{value:"Trust but verify",id:"trust-but-verify",level:3},{value:"Cooperation flaw",id:"cooperation-flaw",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,o.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(n.admonition,{title:"Ubuntu Virtual Machine",type:"note",children:[(0,o.jsxs)(n.p,{children:["This workshop will not work on Windows systems.\nYou can use the Ubuntu VM we provide ",(0,o.jsx)(n.a,{href:"https://drive.google.com/file/d/1WSUo29d9Z8bmcjurvkDUmoAgq1TqaW4H/view?usp=sharing",children:"here"})," (only works on VirtualBox).\nThe username and password are both ",(0,o.jsx)(n.code,{children:"ipwembedded"}),".\nThe VM has the port 3033 forwarded for SSH connection."]}),(0,o.jsx)(n.p,{children:"If you want to have the VM home directory mounted in Windows, use the following commands (with Admin PowerShell):"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-powershell",children:"winget install -e --id WinFsp.WinFsp\nwinget install -e --id SSHFS-Win.SSHFS-Win\nnet use X: \\\\sshfs\\ipwembedded@localhost!3033\n"})})]}),"\n",(0,o.jsxs)(n.p,{children:["If you did not attend the ",(0,o.jsx)(n.strong,{children:"Tock Workshop"}),", please follow the ",(0,o.jsx)(n.a,{href:"/docs/tock_workshop/",children:"Setup Tutorial"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,o.jsxs)(n.p,{children:["For this track we will be using the ",(0,o.jsx)(n.strong,{children:"Nucleo-F429ZI"})," boards. You will need to ",(0,o.jsx)(n.strong,{children:"change the branch"})," you are working on, but first make sure you commit your changes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'git add .\ngit commit -m "tock workshop progress"\n'})}),"\n",(0,o.jsx)(n.p,{children:"Then, to fetch the branch and work on it, run:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"git fetch\ngit checkout track/embedded\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The board's main can be found in the ",(0,o.jsx)(n.code,{children:"boards/nucleo_f429zi"})," subfolder. Try to flash the kernel to the board, using the board's ",(0,o.jsx)(n.code,{children:"Makefile"}),". After you are done flashing, connect to the board using ",(0,o.jsx)(n.code,{children:"tockloader listen"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'[INFO   ] No device name specified. Using default name "tock".\n[INFO   ] No serial port with device name "tock" found.\n[INFO   ] Found 2 serial ports.\nMultiple serial port options found. Which would you like to use?\n[0]     /dev/cu.debug-console - n/a\n[1]     /dev/cu.usbmodem1303 - STM32 STLink\n\nWhich option? [0] 1\n[INFO   ] Using "/dev/cu.usbmodem1303 - STM32 STLink".\n[INFO   ] Listening for serial output.\n\ntock$\n'})}),"\n",(0,o.jsx)(n.h2,{id:"customize-your-kernel",children:"Customize your kernel"}),"\n",(0,o.jsxs)(n.p,{children:["After connecting to Tock's terminal, you can run ",(0,o.jsx)(n.code,{children:"help"})," to see the supported commands. One of them is ",(0,o.jsx)(n.code,{children:"reset"})," and by running it, you can see the default ",(0,o.jsx)(n.em,{children:'"welcome"'})," message."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"tock$ reset\nInitialization complete. Entering main loop\ntock$\n"})}),"\n",(0,o.jsx)(n.p,{children:"Personalize your kernel, by changing the hostname and the welcome message."}),"\n",(0,o.jsx)(n.h2,{id:"print-counter-capsule",children:"Print Counter Capsule"}),"\n",(0,o.jsxs)(n.p,{children:["For this task, you will need to build a capsule that prints a custom message each time it receives a print command from an application, along with a message counter representing the number of commands received. Remember that you will need to implement the ",(0,o.jsx)(n.code,{children:"SyscallDriver"})," trait."]}),"\n",(0,o.jsx)(n.h3,{id:"the-simple-way",children:"The simple way"}),"\n",(0,o.jsxs)(n.p,{children:["Simplest method to do this is to add a ",(0,o.jsx)(n.code,{children:"counter"})," field in the capsule's structure. One issue you will most likely encounter is that the ",(0,o.jsx)(n.code,{children:"command"})," method required by the ",(0,o.jsx)(n.code,{children:"SyscallDriver"})," trait has a immutable reference to ",(0,o.jsx)(n.code,{children:"&self"}),", so you may need to wrap the counter in a wrapper that allows for inner mutability, such as ",(0,o.jsx)(n.code,{children:"Cell"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"the-tock-way",children:"The Tock way"}),"\n",(0,o.jsxs)(n.p,{children:["One issue with the previous approach is that the counter would be shared between the applications. This could be an issue for mutually distrustful application. Fortunately, Tock has a mechanism in place for such situations, called ",(0,o.jsx)(n.code,{children:"Grant"}),"s, which are per-process memory regions allocated by the kernel in a process memory region for a capsule to store that process\u2019s state."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Grant",src:t(74287).A+"",width:"385",height:"340"})}),"\n",(0,o.jsxs)(n.p,{children:["To access this region, you can simply add a new ",(0,o.jsx)(n.code,{children:"grant"})," field in the capsule structure."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="capsules/extra/src/print_counter.rs"',children:"use kernel::grant::{AllowRoCount, AllowRwCount, Grant, UpcallCount};\n\n// TODO: Define `App` structure. Make sure to satisfy trait constraints.\nstruct App;\n\nstruct PrintCounter {\n    grant: Grant<\n        App,\n        UpcallCount<0>,     // Number of upcalls supported by the capsule\n        AllowRoCount<0>,    // Number of Read-Only buffers supported\n        AllowRwCount<0>,    // Number of Read-Write buffers supported\n    >,\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"As before, we will need to define a component for this capsule, to initialize it."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="boards/components/src/print_counter.rs"',children:"#[macro_export]\nmacro_rules! print_counter_component_static {\n    ($(,)?) => {{\n        kernel::static_buf!(capsules_extra::print_counter::PrintCounter)\n    };};\n}\n\npub struct PrintCounterComponent;\n\nimpl Component for PrintCounterComponent {\n    type StaticInput = &'static mut MaybeUninit<capsules_extra::print_counter::PrintCounter>;\n\n    type Output = &'static capsules_extra::print_counter::PrintCounter;\n\n    fn finalize(self, static_memory: Self::StaticInput) -> Self::Output {\n        todo!()\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Grants are a sensitive component of the operating system, so the creation and management operations are considered unsafe, and require\nprivileges to perform. Tock restricts these privileged operations through the use of capabilities, which are tokens implementing ",(0,o.jsx)(n.code,{children:"unsafe"})," traits. Because capsules are forbidden from using unsafe code, these tokens cannot be forged."]}),"\n",(0,o.jsx)(n.p,{children:"Creating a grant is requires a reference to the board's kernel, and a driver number, so we will need to add these parts in the components."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="boards/components/src/print_counter.rs"',children:"pub struct PrintCounterComponent {\n    driver_num: usize,\n    board_kernel: &'static kernel::Kernel,\n}\n\nimpl PrintCounterComponent {\n    pub fn new(driver_num: usize, board_kernel: &'static kernel::Kernel) -> Self {\n        Self {\n            driver_num,\n            board_kernel,\n        }\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The capability needed for grant creating is called ",(0,o.jsx)(n.code,{children:"MemoryAllocationCapability"}),", and it can be found in the ",(0,o.jsx)(n.code,{children:"kernel::capabilities"})," module. The ",(0,o.jsx)(n.code,{children:"kernel"})," also exposes the ",(0,o.jsx)(n.code,{children:"crate_capability!"})," macro for ease of use."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="boards/components/src/print_counter.rs"',children:"impl Component for PrintCounterComponent {\n    // ...\n\n    fn finalize(self, static_memory: Self::StaticInput) -> Self::Output {\n        let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);\n        let grant = self.board_kernel.create_grant(self.driver_num, &grant_cap);\n\n        static_memory.write(capsules_extra::print_counter::PrintCounter::new(grant))\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.mdxAdmonitionTitle,{children:[(0,o.jsx)(n.code,{children:"new"})," constructor"]}),(0,o.jsxs)(n.p,{children:["You will also need to implement the ",(0,o.jsx)(n.code,{children:"new"})," constructor for the ",(0,o.jsx)(n.code,{children:"PrintCounter"})," capsule."]})]}),"\n",(0,o.jsxs)(n.p,{children:["Next, you must implement the ",(0,o.jsx)(n.code,{children:"SyscallDriver"})," trait, where the command logic will be. For the ",(0,o.jsx)(n.code,{children:"allocate_grant"})," method implementation, it is enough to use the ",(0,o.jsx)(n.code,{children:"enter"})," method of the Grant which takes a closure with two parameters."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"fn allocate_grant(&self, process_id: kernel::ProcessId) -> Result<(), kernel::process::Error> {\n    self.grant.enter(process_id, |_, _| {})\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For the command logic, you must also use the ",(0,o.jsx)(n.code,{children:"enter"})," API. The first parameter of the closure will be a mutable reference to a ",(0,o.jsx)(n.code,{children:"GrantData"})," wrapper over the previously defined ",(0,o.jsx)(n.code,{children:"App"}),". The wrapper is transparent, meaning it permits accessing fields of the generic type."]}),"\n",(0,o.jsxs)(n.p,{children:["The next step is configuring the capsule in the board's main file. Remember you need to add the capsule in the ",(0,o.jsx)(n.code,{children:"NucleoF429ZI"})," structure, the ",(0,o.jsx)(n.code,{children:"SyscallDriverLookup"})," and initialize the printer counter capsule."]}),"\n",(0,o.jsx)(n.h2,{id:"the-role-of-a-scheduler",children:"The role of a Scheduler"}),"\n",(0,o.jsxs)(n.p,{children:["This task aims to illustrate the importance of OS preemption in the context of untrusted applications. Currently the scheduler used by the board is ",(0,o.jsx)(n.code,{children:"kernel::scheduler::RoundRobinSched"}),", which implements a classical scheduling algorithm, allowing each process to run up to a maximum time slice called ",(0,o.jsx)(n.strong,{children:"quanta"}),". In the event that an application tries starving all other processes, the kernel will interrupt the malicious application after its quanta expires and will then schedule another process."]}),"\n",(0,o.jsx)(n.h3,{id:"trust-but-verify",children:"Trust but verify"}),"\n",(0,o.jsxs)(n.p,{children:["Your task will be to verify the previous claims, by flashing two C applications. One of them will be the ",(0,o.jsx)(n.code,{children:"blink"})," example. After flashing the kernel by running ",(0,o.jsx)(n.code,{children:"make flash"})," in the board's main directory (",(0,o.jsx)(n.code,{children:"boards/nucleo_f429zi"}),"), you can load the application by running ",(0,o.jsx)(n.code,{children:"make flash"})," in the example's root folder (",(0,o.jsx)(n.code,{children:"example/blink"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["As there are no ",(0,o.jsx)(n.em,{children:'"malicious"'})," examples, we will have to add them on our own. In this case, an app that would print a message, then just infinitely spin in a ",(0,o.jsx)(n.code,{children:"while"})," loop is enough. For this, you can adapt the ",(0,o.jsx)(n.code,{children:"examples/c_hello"})," example, the flash it."]}),"\n",(0,o.jsxs)(n.p,{children:["If you managed to flash both applications, you should be able to connect to the board using ",(0,o.jsx)(n.code,{children:"tockloader listen"})," and see a similar output when running ",(0,o.jsx)(n.code,{children:"list"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:'tockloader listen\n[INFO   ] No device name specified. Using default name "tock".\n[INFO   ] No serial port with device name "tock" found.\n[INFO   ] Found 2 serial ports.\nMultiple serial port options found. Which would you like to use?\n[0]     /dev/cu.debug-console - n/a\n[1]     /dev/cu.usbmodem1103 - STM32 STLink\n\nWhich option? [0] 1\n[INFO   ] Using "/dev/cu.usbmodem1103 - STM32 STLink".\n[INFO   ] Listening for serial output.\n\ntock$ list\n PID    ShortID    Name                Quanta  Syscalls  Restarts  Grants  State\n 0      Unique     blink                    0       289         0   1/11   Yielded\n 1      Unique     ws-demo                640         6         0   1/11   Running\ntock$\n'})}),"\n",(0,o.jsx)(n.p,{children:"You should be able to see the on-board LEDs flashing on the board."}),"\n",(0,o.jsx)(n.h3,{id:"cooperation-flaw",children:"Cooperation flaw"}),"\n",(0,o.jsxs)(n.p,{children:["Now, let's test the same scenario, but with a cooperative scheduling mechanism. You have to first change the kernel's scheduler in the board's ",(0,o.jsx)(n.code,{children:"main.rs"})," file to use the ",(0,o.jsx)(n.code,{children:"scheduler::cooperative::CooperativeSched"}),". Then you must re-flash the kernel by running ",(0,o.jsx)(n.code,{children:"make flash"}),". Fortunately flashing the kernel should preserve the applications, so you will not have to re-flash them as well."]}),"\n",(0,o.jsxs)(n.p,{children:["After you are done flashing, check that both applications are present. You can try to reset the board a few times by running ",(0,o.jsx)(n.code,{children:"reset"})," in tock's process console (the terminal you open by running ",(0,o.jsx)(n.code,{children:"tockloader listen"}),")."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},74287:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/grant-217c251c8d570f97ad0ccc8657376c07.png"}}]);