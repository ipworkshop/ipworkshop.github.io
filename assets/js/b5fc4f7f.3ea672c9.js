"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[476],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>c});var t=i(96540);const r={},o=t.createContext(r);function s(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(o.Provider,{value:e},n.children)}},69908:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"desktop_applications/Slint/Reactivity","title":"Slint Reactivity","description":"Introduction","source":"@site/docs/desktop_applications/03_Slint/02_Reactivity.md","sourceDirName":"desktop_applications/03_Slint","slug":"/desktop_applications/Slint/Reactivity","permalink":"/docs/desktop_applications/Slint/Reactivity","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/03_Slint/02_Reactivity.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Slint","permalink":"/docs/desktop_applications/Slint/Introduction"},"next":{"title":"The .slint File","permalink":"/docs/desktop_applications/Slint/Slint-file"}}');var r=i(74848),o=i(28453);const s={},c="Slint Reactivity",l={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Example: Mouse Tracking and Color Change",id:"example-mouse-tracking-and-color-change",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Performance and Dependency Tracking",id:"performance-and-dependency-tracking",level:2},{value:"Property Expressions",id:"property-expressions",level:2},{value:"Purity in Bindings",id:"purity-in-bindings",level:2},{value:"Two-Way Bindings",id:"two-way-bindings",level:2}];function d(n){const e={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"slint-reactivity",children:"Slint Reactivity"})}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Reactivity"})," is a core concept in Slint. It allows you to create complex, dynamic user interfaces with far less code.",(0,r.jsx)(e.br,{}),"\n","In Slint, UI elements automatically update when the properties they depend on change \u2014 without requiring manual refresh logic."]}),"\n",(0,r.jsx)(e.h2,{id:"example-mouse-tracking-and-color-change",children:"Example: Mouse Tracking and Color Change"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-slint",children:'export component MyComponent {\n    width: 400px; height: 400px;\n\n    Rectangle {\n        background: #151515;\n    }\n\n    ta := TouchArea {}\n\n    myRect := Rectangle {\n        x: ta.mouse-x;\n        y: ta.mouse-y;\n        width: 40px;\n        height: 40px;\n        background: ta.pressed ? orange : white;\n    }\n\n    Text {\n        x: 5px; y: 5px;\n        text: "x: " + myRect.x / 1px;\n        color: white;\n    }\n\n    Text {\n        x: 5px; y: 15px;\n        text: "y: " + myRect.y / 1px;\n        color: white;\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["The ",(0,r.jsx)(e.strong,{children:"rectangle follows the mouse"})," using ",(0,r.jsx)(e.code,{children:"x: ta.mouse-x;"})," and ",(0,r.jsx)(e.code,{children:"y: ta.mouse-y;"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Color changes on click"}),": ",(0,r.jsx)(e.code,{children:"background: ta.pressed ? orange : white;"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["Text labels ",(0,r.jsx)(e.strong,{children:"automatically update"})," to show the rectangle's current position."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This works because:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["The ",(0,r.jsx)(e.code,{children:"TouchArea"})," exposes ",(0,r.jsx)(e.code,{children:"mouse-x"}),", ",(0,r.jsx)(e.code,{children:"mouse-y"}),", and ",(0,r.jsx)(e.code,{children:"pressed"})," properties."]}),"\n",(0,r.jsx)(e.li,{children:"When these properties change, all bound expressions are automatically re-evaluated."}),"\n",(0,r.jsx)(e.li,{children:"The UI updates only where dependencies have changed."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"performance-and-dependency-tracking",children:"Performance and Dependency Tracking"}),"\n",(0,r.jsx)(e.p,{children:"Slint evaluates bindings lazily:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Dependencies are registered when a property is accessed during evaluation."}),"\n",(0,r.jsx)(e.li,{children:"When a property changes, only dependent expressions are re-evaluated."}),"\n",(0,r.jsx)(e.li,{children:"This ensures high performance, even for complex UIs."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"property-expressions",children:"Property Expressions"}),"\n",(0,r.jsx)(e.p,{children:"Property bindings can be simple or complex:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-slint",children:"// Tracks foo.x\nx: foo.x;\n\n// Conditional expression\nx: foo.x > 100px ? 0px : 400px;\n\n// Clamped value\nx: clamp(foo.x, 0px, 400px);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["You can also use ",(0,r.jsx)(e.strong,{children:"functions"})," for clarity:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-slint",children:'export component MyComponent {\n    width: 400px; height: 400px;\n\n    pure function lengthToInt(n: length) -> int {\n        return (n / 1px);\n    }\n\n    ta := TouchArea {}\n\n    myRect := Rectangle {\n        x: ta.mouse-x;\n        y: ta.mouse-y;\n        width: 40px;\n        height: 40px;\n        background: ta.pressed ? orange : white;\n    }\n\n    Text {\n        x: 5px; y: 5px;\n        text: "x: " + lengthToInt(myRect.x);\n    }\n    Text {\n        x: 5px; y: 15px;\n        text: "y: " + lengthToInt(myRect.y);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"purity-in-bindings",children:"Purity in Bindings"}),"\n",(0,r.jsxs)(e.p,{children:["For reactivity to work correctly, bindings must be ",(0,r.jsx)(e.strong,{children:"pure"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Evaluating a property should not change any other observable state."}),"\n",(0,r.jsx)(e.li,{children:"The Slint compiler enforces purity in binding expressions, pure functions, and pure callbacks."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Example:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-slint",children:"export component Example {\n    pure callback foo() -> int;\n    public pure function bar(x: int) -> int {\n        return x + foo();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"two-way-bindings",children:"Two-Way Bindings"}),"\n",(0,r.jsxs)(e.p,{children:["Two-way bindings keep two properties in sync using ",(0,r.jsx)(e.code,{children:"<=>"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-slint",children:"export component Example  {\n    in property<brush> rect-color <=> r.background;\n    in property rect-color2 <=> r.background;\n\n    r:= Rectangle {\n        width: parent.width;\n        height: parent.height;\n        background: blue;\n    }\n}\n"})})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);