"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[7234],{6673:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"desktop_applications/Rust/Variables-and-data-types","title":"Variables and data types","description":"Now let\'s dive into how Rust handles variables and data. This is where you\'ll see some key differences from languages like JavaScript or Python.","source":"@site/docs/desktop_applications/02_Rust/03_Variables-and-data-types.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Variables-and-data-types","permalink":"/docs/desktop_applications/Rust/Variables-and-data-types","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/03_Variables-and-data-types.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Variables and data types"},"sidebar":"tutorialSidebar","previous":{"title":"Project Structure","permalink":"/docs/desktop_applications/Rust/Project-structure"},"next":{"title":"Control Flow and Functions","permalink":"/docs/desktop_applications/Rust/Functions-and-control-flow"}}');var t=s(74848),a=s(28453);const l={title:"Variables and data types"},r=void 0,o={},c=[{value:"<strong>Immutability by Default:</strong>",id:"immutability-by-default",level:4},{value:"<strong>Type Inference vs. Explicit Types:</strong>",id:"type-inference-vs-explicit-types",level:4},{value:"<strong>Common Primitive Data Types:</strong>",id:"common-primitive-data-types",level:4},{value:"<strong>Constants:</strong>",id:"constants",level:4},{value:"<strong>Shadowing:</strong>",id:"shadowing",level:4}];function d(e){const n={code:"code",em:"em",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Now let's dive into how Rust handles variables and data. This is where you'll see some key differences from languages like JavaScript or Python."}),"\n",(0,t.jsx)(n.h4,{id:"immutability-by-default",children:(0,t.jsx)(n.strong,{children:"Immutability by Default:"})}),"\n",(0,t.jsxs)(n.p,{children:["This is one of Rust's core principles. By default, variables in Rust are ",(0,t.jsx)(n.strong,{children:"immutable"}),", meaning once you give them a value, you cannot change that value. This helps prevent unexpected bugs."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Declaring an Immutable Variable:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let x = 5; // \'x\' is immutable. Its value is 5, and it cannot be changed.\n    println!("The value of x is: {}", x);\n    // x = 6; // This would cause a compile-time error! Try uncommenting it.\n    // println!("The value of x is: {}", x);\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Making a Variable Mutable:"}),"\nIf you ",(0,t.jsx)(n.em,{children:"do"})," want to change a variable's value, you must explicitly mark it as ",(0,t.jsx)(n.code,{children:"mut"})," (short for mutable)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn main() {\n    let mut y = 10; // 'y' is mutable. We can change its value.\n    println!(\"The initial value of y is: {}\", y);\n    y = 15; // This is allowed because 'y' is mutable.\n    println!(\"The new value of y is: {}\", y);\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"type-inference-vs-explicit-types",children:(0,t.jsx)(n.strong,{children:"Type Inference vs. Explicit Types:"})}),"\n",(0,t.jsxs)(n.p,{children:["Rust is a ",(0,t.jsx)(n.strong,{children:"statically typed"})," language, meaning it knows the type of every variable at compile time. However, it's also very smart and can often ",(0,t.jsx)(n.strong,{children:"infer"})," the type based on the value you assign. You don't always ",(0,t.jsx)(n.em,{children:"have"})," to write the type."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Inference (Common):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn main() {\n    let age = 30; // Rust infers 'age' is an integer (i32 by default)\n    let pi = 3.14; // Rust infers 'pi' is a floating-point number (f64 by default)\n    let is_active = true; // Rust infers 'is_active' is a boolean\n    let initial = 'A'; // Rust infers 'initial' is a character (single quotes)\n    let greeting = \"Hello\"; // Rust infers 'greeting' is a string slice (&str)\n    println!(\"Age: {}, Pi: {}, Active: {}, Initial: {}, Greeting: {}\", age, pi, is_active, initial, greeting);\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explicit Type Annotation (When needed or for clarity):"}),"\nYou can explicitly tell Rust the type of a variable. This is useful when inference is ambiguous or for better readability.","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let count: i64 = 100_000_000_000; // Explicitly a 64-bit integer\n    let temperature: f32 = 25.5; // Explicitly a 32-bit float\n    let message: &str = "Welcome!"; // Explicitly a string slice\n    println!("Count: {}, Temp: {}, Message: {}", count, temperature, message);\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"common-primitive-data-types",children:(0,t.jsx)(n.strong,{children:"Common Primitive Data Types:"})}),"\n",(0,t.jsx)(n.p,{children:"Rust has several built-in primitive types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integers:"})," ",(0,t.jsx)(n.code,{children:"i8"}),", ",(0,t.jsx)(n.code,{children:"i16"}),", ",(0,t.jsx)(n.code,{children:"i32"})," (default), ",(0,t.jsx)(n.code,{children:"i64"}),", ",(0,t.jsx)(n.code,{children:"i128"})," (signed integers) and ",(0,t.jsx)(n.code,{children:"u8"}),", ",(0,t.jsx)(n.code,{children:"u16"}),", ",(0,t.jsx)(n.code,{children:"u32"}),", ",(0,t.jsx)(n.code,{children:"u64"}),", ",(0,t.jsx)(n.code,{children:"u128"})," (unsigned integers). The number indicates the bits they use. ",(0,t.jsx)(n.code,{children:"isize"})," and ",(0,t.jsx)(n.code,{children:"usize"})," depend on the architecture (e.g., 32-bit or 64-bit)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Floating-Point Numbers:"})," ",(0,t.jsx)(n.code,{children:"f32"})," (single-precision), ",(0,t.jsx)(n.code,{children:"f64"})," (double-precision, default)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Booleans:"})," ",(0,t.jsx)(n.code,{children:"bool"})," (",(0,t.jsx)(n.code,{children:"true"})," or ",(0,t.jsx)(n.code,{children:"false"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Characters:"})," ",(0,t.jsx)(n.code,{children:"char"})," (single Unicode scalar value, uses single quotes, e.g., ",(0,t.jsx)(n.code,{children:"'A'"}),", ",(0,t.jsx)(n.code,{children:"'\ud83d\ude0a'"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Strings:"})," We'll learn more about strings later, but for now, know that ",(0,t.jsx)(n.code,{children:"&str"})," (string slice, immutable reference to text) and ",(0,t.jsx)(n.code,{children:"String"})," (growable, owned string) are the main types."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"constants",children:(0,t.jsx)(n.strong,{children:"Constants:"})}),"\n",(0,t.jsx)(n.p,{children:"Constants are always immutable and must have their type explicitly annotated. They can be declared in any scope, including global."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'const MAX_POINTS: u32 = 100_000; // Constants are typically named in SCREAMING_SNAKE_CASE\nconst APP_VERSION: &str = "1.0.0";\nfn main() {\n    println!("Max points: {}", MAX_POINTS);\n    println!("App version: {}", APP_VERSION);\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"shadowing",children:(0,t.jsx)(n.strong,{children:"Shadowing:"})}),"\n",(0,t.jsxs)(n.p,{children:["Rust allows you to declare a ",(0,t.jsx)(n.em,{children:"new"}),' variable with the same name as a previous variable. This "shadows" the previous variable, meaning the new variable takes precedence. This is different from ',(0,t.jsx)(n.code,{children:"mut"}),", as you're creating a new variable, not changing an existing one."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn main() {\n    let spaces = \"   \"; // First 'spaces' variable (string slice)\n    println!(\"Spaces (initial): '{}'\", spaces);\n    let spaces = spaces.len(); // 'spaces' is now a new variable, holding the length (an integer)\n    println!(\"Spaces (length): {}\", spaces); // The old 'spaces' is no longer accessible\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Shadowing is useful when you want to transform a variable's value but keep the same name, without needing to make the original variable mutable."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var i=s(96540);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);