"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[7866],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var r=s(96540);const i={},l=r.createContext(i);function t(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(l.Provider,{value:n},e.children)}},87273:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"desktop_applications/Rust/Ownership-and-borrowing","title":"Ownership, Borrowing, and Slices in Rust","description":"In this lesson, we\u2019ll take a closer look at three of Rust\u2019s most important concepts: ownership, borrowing, and slices.","source":"@site/docs/desktop_applications/02_Rust/05_Ownership-and-borrowing.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Ownership-and-borrowing","permalink":"/docs/desktop_applications/Rust/Ownership-and-borrowing","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/05_Ownership-and-borrowing.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Ownership, Borrowing, and Slices in Rust"},"sidebar":"tutorialSidebar","previous":{"title":"Control Flow and Functions","permalink":"/docs/desktop_applications/Rust/Functions-and-control-flow"},"next":{"title":"Pattern Matching","permalink":"/docs/desktop_applications/Rust/Pattern-matching"}}');var i=s(74848),l=s(28453);const t={title:"Ownership, Borrowing, and Slices in Rust"},o=void 0,c={},a=[{value:"1. Ownership",id:"1-ownership",level:3},{value:"<strong>The 3 Ownership Rules</strong>",id:"the-3-ownership-rules",level:3},{value:"<strong>Example:</strong>",id:"example",level:4},{value:"<strong>Copy vs Clone</strong>",id:"copy-vs-clone",level:3},{value:"<strong>1. Copy Types (Stack-Only)</strong>",id:"1-copy-types-stack-only",level:4},{value:"<strong>2. Move Semantics (Heap Data)</strong>",id:"2-move-semantics-heap-data",level:4},{value:"<strong>3. Clone (Deep Copy)</strong>",id:"3-clone-deep-copy",level:4},{value:"2. Borrowing and References",id:"2-borrowing-and-references",level:3},{value:"<strong>Immutable References (<code>&amp;T</code>)</strong>",id:"immutable-references-t",level:3},{value:"<strong>Mutable References (<code>&amp;mut T</code>)</strong>",id:"mutable-references-mut-t",level:3},{value:"<strong>Borrowing Rules</strong>",id:"borrowing-rules",level:3},{value:"3. Slices",id:"3-slices",level:2},{value:"<strong>String Slices (<code>&amp;str</code>)</strong>",id:"string-slices-str",level:3},{value:"<strong>Slices in Functions</strong>",id:"slices-in-functions",level:3},{value:"<strong>Array Slices</strong>",id:"array-slices",level:3}];function d(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In this lesson, we\u2019ll take a closer look at three of Rust\u2019s most important concepts: ",(0,i.jsx)(n.strong,{children:"ownership"}),", ",(0,i.jsx)(n.strong,{children:"borrowing"}),", and ",(0,i.jsx)(n.strong,{children:"slices"}),".",(0,i.jsx)(n.br,{}),"\n","These are the foundations of Rust\u2019s ",(0,i.jsx)(n.strong,{children:"memory safety"}),", allowing it to manage memory ",(0,i.jsx)(n.strong,{children:"without a garbage collector"})," and to ",(0,i.jsx)(n.strong,{children:"prevent data races at compile time"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"1-ownership",children:"1. Ownership"}),"\n",(0,i.jsxs)(n.p,{children:["Ownership is ",(0,i.jsx)(n.strong,{children:"Rust\u2019s memory management system"}),". Instead of a garbage collector, Rust tracks ",(0,i.jsx)(n.strong,{children:"who owns each piece of data"})," and ",(0,i.jsx)(n.strong,{children:"frees it automatically"})," when no longer needed."]}),"\n",(0,i.jsx)(n.p,{children:"Key ideas:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No garbage collector."}),"\n",(0,i.jsx)(n.li,{children:"Strict rules, checked during compilation."}),"\n",(0,i.jsx)(n.li,{children:"Violating them causes compilation errors."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Stack"})," and ",(0,i.jsx)(n.strong,{children:"Heap"})," memory:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Stack"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Stores data in ",(0,i.jsx)(n.strong,{children:"Last-In, First-Out (LIFO)"})," order."]}),"\n",(0,i.jsx)(n.li,{children:"Extremely fast because the memory location is always at the \u201ctop of the stack.\u201d"}),"\n",(0,i.jsxs)(n.li,{children:["Requires values to have a ",(0,i.jsx)(n.strong,{children:"known, fixed size"})," at compile time."]}),"\n",(0,i.jsx)(n.li,{children:"Automatically freed when the variable goes out of scope."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Heap"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Stores ",(0,i.jsx)(n.strong,{children:"dynamically sized or growable data"})," (like ",(0,i.jsx)(n.code,{children:"String"})," or ",(0,i.jsx)(n.code,{children:"Vec"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Memory must be ",(0,i.jsx)(n.strong,{children:"requested at runtime"})," from the allocator."]}),"\n",(0,i.jsxs)(n.li,{children:["Access is ",(0,i.jsx)(n.strong,{children:"slower"})," because you must ",(0,i.jsx)(n.strong,{children:"follow a pointer"})," from the stack to the heap."]}),"\n",(0,i.jsxs)(n.li,{children:["Memory must eventually be freed, which is where ",(0,i.jsx)(n.strong,{children:"ownership rules"})," come in."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Rust\u2019s ",(0,i.jsx)(n.strong,{children:"ownership system"})," exists to ",(0,i.jsx)(n.strong,{children:"safely manage heap memory"}),", automatically cleaning up resources and preventing data races."]}),"\n",(0,i.jsx)(n.h3,{id:"the-3-ownership-rules",children:(0,i.jsx)(n.strong,{children:"The 3 Ownership Rules"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Each value in Rust has a single owner"})," (a variable that \u201cowns\u201d the value)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When the owner goes out of scope, the value is dropped"})," (memory freed)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ownership can be moved, but not copied by default"})," (unless the type is ",(0,i.jsx)(n.code,{children:"Copy"})," or you explicitly ",(0,i.jsx)(n.code,{children:"clone"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example",children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello"); // s1 owns the string\n    let s2 = s1; // ownership moves to s2\n\n    // println!("{}", s1); // ERROR: s1 no longer owns the value\n    println!("{}", s2); // Works\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["After ",(0,i.jsx)(n.code,{children:"s2 = s1"}),", ",(0,i.jsx)(n.strong,{children:"s1 is invalidated"})," to prevent ",(0,i.jsx)(n.strong,{children:"double free"})," errors."]}),"\n",(0,i.jsxs)(n.li,{children:["When ",(0,i.jsx)(n.code,{children:"main"})," ends, ",(0,i.jsx)(n.code,{children:"s2"})," is dropped, and Rust frees the memory automatically."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"copy-vs-clone",children:(0,i.jsx)(n.strong,{children:"Copy vs Clone"})}),"\n",(0,i.jsxs)(n.p,{children:["Rust ",(0,i.jsx)(n.strong,{children:"treats data differently"})," depending on ",(0,i.jsx)(n.strong,{children:"where it lives"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stack-only data (simple types)"})," \u2192 ",(0,i.jsx)(n.strong,{children:"Copied automatically"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Heap-allocated data (complex types)"})," \u2192 ",(0,i.jsx)(n.strong,{children:"Moved by default"})]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"1-copy-types-stack-only",children:(0,i.jsx)(n.strong,{children:"1. Copy Types (Stack-Only)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Examples: integers (",(0,i.jsx)(n.code,{children:"i32"}),"), booleans (",(0,i.jsx)(n.code,{children:"bool"}),"), characters (",(0,i.jsx)(n.code,{children:"char"}),"), and tuples of ",(0,i.jsx)(n.code,{children:"Copy"})," types."]}),"\n",(0,i.jsxs)(n.li,{children:["These types are ",(0,i.jsx)(n.strong,{children:"small and fixed-size"}),", so Rust ",(0,i.jsx)(n.strong,{children:"copies them cheaply"})," instead of moving them."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let x = 5;     // i32 is a Copy type\n    let y = x;     // A new copy of 5 is created on the stack\n\n    println!("x = {}, y = {}", x, y); // Both valid\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Stack values are ",(0,i.jsx)(n.strong,{children:"duplicated instantly"}),", so ",(0,i.jsx)(n.code,{children:"x"})," still owns its 5 and ",(0,i.jsx)(n.code,{children:"y"})," has its own 5."]}),"\n",(0,i.jsx)(n.h4,{id:"2-move-semantics-heap-data",children:(0,i.jsx)(n.strong,{children:"2. Move Semantics (Heap Data)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Types like ",(0,i.jsx)(n.code,{children:"String"}),", ",(0,i.jsx)(n.code,{children:"Vec<T>"}),", or any custom type ",(0,i.jsx)(n.strong,{children:"holding heap memory"})," are ",(0,i.jsx)(n.strong,{children:"moved by default"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Assigning them ",(0,i.jsx)(n.strong,{children:"transfers ownership"})," instead of copying the underlying heap memory (which could be expensive)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello"); // s1 owns the heap data\n    let s2 = s1;                    // s1 is MOVED into s2\n\n    // println!("{}", s1); // ERROR: s1 is no longer valid\n    println!("{}", s2);   // Only s2 can be used now\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why move instead of copy?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Copying large heap data automatically could be ",(0,i.jsx)(n.strong,{children:"slow"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Move avoids extra work while still keeping memory safe."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"3-clone-deep-copy",children:(0,i.jsx)(n.strong,{children:"3. Clone (Deep Copy)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If you ",(0,i.jsx)(n.strong,{children:"want a real copy of the heap data"}),", call ",(0,i.jsx)(n.code,{children:".clone()"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let s2 = s1.clone(); // Copies heap data as well\n\n    println!("s1 = {}, s2 = {}", s1, s2); // Both valid\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Move"}),": only the pointer and metadata are copied; old owner is invalid. (Cheap)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clone"}),": heap data is copied too; both owners are valid. (More expensive)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Think of ",(0,i.jsx)(n.strong,{children:"ownership like house keys"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Copy"})," - Making a ",(0,i.jsx)(n.strong,{children:"duplicate key"})," for a small box (cheap and simple)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Move"})," - Handing your ",(0,i.jsx)(n.strong,{children:"only key"})," to someone else (you can\u2019t access it anymore)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clone"})," - ",(0,i.jsx)(n.strong,{children:"Building a whole new house"})," with its own key (expensive)."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"2-borrowing-and-references",children:"2. Borrowing and References"}),"\n",(0,i.jsxs)(n.p,{children:["If we want to ",(0,i.jsx)(n.strong,{children:"use a value in multiple places"})," without transferring ownership.",(0,i.jsx)(n.br,{}),"\n","Rust solves this with ",(0,i.jsx)(n.strong,{children:"borrowing"}),", which allows ",(0,i.jsx)(n.strong,{children:"references"})," to a value."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"reference"})," is like a ",(0,i.jsx)(n.strong,{children:"pointer"})," that guarantees memory safety."]}),"\n",(0,i.jsxs)(n.li,{children:["Borrowing allows ",(0,i.jsx)(n.strong,{children:"access without taking ownership"}),", so the original variable stays valid."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No runtime overhead"}),": the compiler ensures safety rules."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"immutable-references-t",children:(0,i.jsxs)(n.strong,{children:["Immutable References (",(0,i.jsx)(n.code,{children:"&T"}),")"]})}),"\n",(0,i.jsxs)(n.p,{children:["An immutable reference lets you ",(0,i.jsx)(n.strong,{children:"read data without taking ownership"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s = String::from("hello");\n\n    let len = calculate_length(&s); // Borrow immutably\n    println!("The length of \'{}\' is {}.", s, len); // s is still valid\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len() // Can read, cannot modify\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&s"})," is a ",(0,i.jsx)(n.strong,{children:"reference"})," (borrow)."]}),"\n",(0,i.jsxs)(n.li,{children:["The original variable ",(0,i.jsx)(n.strong,{children:"keeps ownership"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["You ",(0,i.jsx)(n.strong,{children:"cannot modify"})," through an immutable reference."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"mutable-references-mut-t",children:(0,i.jsxs)(n.strong,{children:["Mutable References (",(0,i.jsx)(n.code,{children:"&mut T"}),")"]})}),"\n",(0,i.jsxs)(n.p,{children:["If we want to ",(0,i.jsx)(n.strong,{children:"modify"})," a value without transferring ownership, we use ",(0,i.jsx)(n.strong,{children:"mutable references"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("hello");\n\n    change(&mut s); // Borrow mutably\n    println!("{}", s); // Output: hello, world\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Only ",(0,i.jsx)(n.strong,{children:"one mutable reference"})," is allowed at a time."]}),"\n",(0,i.jsxs)(n.li,{children:["This prevents ",(0,i.jsx)(n.strong,{children:"data races"}),", ensuring ",(0,i.jsx)(n.strong,{children:"safe concurrent access"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"borrowing-rules",children:(0,i.jsx)(n.strong,{children:"Borrowing Rules"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"You can have either:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Any number of ",(0,i.jsx)(n.strong,{children:"immutable references"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"OR"})," one ",(0,i.jsx)(n.strong,{children:"mutable reference"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"References must always be valid"})," (no dangling pointers)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["These rules ensure Rust can ",(0,i.jsx)(n.strong,{children:"guarantee memory safety"})," at compile time."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-slices",children:"3. Slices"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"slice"})," is a ",(0,i.jsx)(n.strong,{children:"reference to part of a collection"}),".",(0,i.jsx)(n.br,{}),"\n","Slices let you ",(0,i.jsx)(n.strong,{children:"work with sub-sections of data without copying"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"string-slices-str",children:(0,i.jsxs)(n.strong,{children:["String Slices (",(0,i.jsx)(n.code,{children:"&str"}),")"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let s = String::from("hello world");\n\n    let hello = &s[0..5]; // Slice of "hello"\n    let world = &s[6..11]; // Slice of "world"\n\n    println!("{} {}", hello, world);\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&s[start..end]"})," creates a slice from ",(0,i.jsx)(n.code,{children:"start"})," (inclusive) to ",(0,i.jsx)(n.code,{children:"end"})," (exclusive)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&s[..]"})," creates a slice of the ",(0,i.jsx)(n.strong,{children:"entire string"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"slices-in-functions",children:(0,i.jsx)(n.strong,{children:"Slices in Functions"})}),"\n",(0,i.jsxs)(n.p,{children:["Slices are commonly used to ",(0,i.jsx)(n.strong,{children:"avoid copying data"})," when processing collections:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn first_word(s: &str) -> &str { // Accepts &String or string literal\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[..i]; // Slice until first space\n        }\n    }\n\n    &s[..] // If no space, return entire string\n}\n\nfn main() {\n    let s = String::from("hello world");\n    let word = first_word(&s);\n    println!("First word: {}", word);\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"&str"})," is already a ",(0,i.jsx)(n.strong,{children:"string slice"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Returning a slice is ",(0,i.jsx)(n.strong,{children:"efficient"})," and avoids extra allocations."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"array-slices",children:(0,i.jsx)(n.strong,{children:"Array Slices"})}),"\n",(0,i.jsx)(n.p,{children:"Slices also work with arrays:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let arr = [1, 2, 3, 4, 5]; \n    let slice = &arr[1..4]; // Elements 2, 3, 4\n\n    for val in slice {\n        println!("{}", val);\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Array slices are ",(0,i.jsx)(n.code,{children:"&[T]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["They ",(0,i.jsx)(n.strong,{children:"borrow part of the array"})," without copying it."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);