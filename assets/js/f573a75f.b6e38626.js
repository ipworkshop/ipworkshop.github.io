"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[6303],{11739:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/i2c_10bit_address_transmission-7b5391881b3650f425af60363c835c64.svg"},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>r});var t=i(96540);const s={},a=t.createContext(s);function d(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(a.Provider,{value:n},e.children)}},36507:(e,n,i)=>{i.d(n,{A:()=>t});const t="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI2OTFweCIgaGVpZ2h0PSIyMjFweCIgdmlld0JveD0iLTAuNSAtMC41IDY5MSAyMjEiPjxkZWZzPjxzdHlsZT5Aa2V5ZnJhbWVzIGdlLWZsb3ctYW5pbWF0aW9uLTNBNHIyVmhzclJtdzN1SURUTGFoIHsmI3hhOyAgdG8geyYjeGE7ICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAwOyYjeGE7ICB9JiN4YTt9PC9zdHlsZT48L2RlZnM+PGc+PGc+PHBhdGggZD0iTSAxMzAuMSAzNy41IEwgNDIwIDM3LjUgTCA0MjAgMTQ5LjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzNhN2U4NiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiIHN0cm9rZS1kYXNoYXJyYXk9IjgiIHN0eWxlPSJhbmltYXRpb246IDEwMDBtcyBlYXNlLWluLW91dCAwcyBpbmZpbml0ZSBhbHRlcm5hdGUgbm9uZSBydW5uaW5nIGdlLWZsb3ctYW5pbWF0aW9uLTNBNHIyVmhzclJtdzN1SURUTGFoOyBzdHJva2UtZGFzaG9mZnNldDogMTZweDsiLz48cGF0aCBkPSJNIDEyMy4zNSAzNy41IEwgMTMyLjM1IDMzIEwgMTMwLjEgMzcuNSBMIDEzMi4zNSA0MiBaIiBmaWxsPSIjM2E3ZTg2IiBzdHJva2U9IiMzYTdlODYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHBhdGggZD0iTSA0MjAgMTU2LjY1IEwgNDE1LjUgMTQ3LjY1IEwgNDIwIDE0OS45IEwgNDI0LjUgMTQ3LjY1IFoiIGZpbGw9IiMzYTdlODYiIHN0cm9rZT0iIzNhN2U4NiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48L2c+PGc+PHBhdGggZD0iTSAxMzAuMSAzNy41IEwgMjgwIDM3LjUgTCAyODAgMTQ5LjkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzNhN2U4NiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiIHN0cm9rZS1kYXNoYXJyYXk9IjgiIHN0eWxlPSJhbmltYXRpb246IDEwMDBtcyBlYXNlLWluLW91dCAwcyBpbmZpbml0ZSBhbHRlcm5hdGUgbm9uZSBydW5uaW5nIGdlLWZsb3ctYW5pbWF0aW9uLTNBNHIyVmhzclJtdzN1SURUTGFoOyBzdHJva2UtZGFzaG9mZnNldDogMTZweDsiLz48cGF0aCBkPSJNIDEyMy4zNSAzNy41IEwgMTMyLjM1IDMzIEwgMTMwLjEgMzcuNSBMIDEzMi4zNSA0MiBaIiBmaWxsPSIjM2E3ZTg2IiBzdHJva2U9IiMzYTdlODYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHBhdGggZD0iTSAyODAgMTU2LjY1IEwgMjc1LjUgMTQ3LjY1IEwgMjgwIDE0OS45IEwgMjg0LjUgMTQ3LjY1IFoiIGZpbGw9IiMzYTdlODYiIHN0cm9rZT0iIzNhN2U4NiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48L2c+PGc+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7IiBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAyNHB4OyBtYXJnaW4tbGVmdDogMTY1cHg7Ij48ZGl2IHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogIzRjN2M4NTsgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAxMXB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDc2LCAxMjQsIDEzMyk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgd2hpdGUtc3BhY2U6IG5vd3JhcDsiPlNEQTwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSIxNjUiIHk9IjI3IiBmaWxsPSIjNGM3Yzg1IiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjExcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlNEQTwvdGV4dD48L3N3aXRjaD48L2c+PC9nPjxnPjxwYXRoIGQ9Ik0gMTMwLjEgMzcuNSBMIDYwMCAzNy41IEwgNjAwIDE0OS45IiBmaWxsPSJub25lIiBzdHJva2U9IiMzYTdlODYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIiBzdHJva2UtZGFzaGFycmF5PSI4IiBzdHlsZT0iYW5pbWF0aW9uOiAxMDAwbXMgZWFzZS1pbi1vdXQgMHMgaW5maW5pdGUgYWx0ZXJuYXRlIG5vbmUgcnVubmluZyBnZS1mbG93LWFuaW1hdGlvbi0zQTRyMlZoc3JSbXczdUlEVExhaDsgc3Ryb2tlLWRhc2hvZmZzZXQ6IDE2cHg7Ii8+PHBhdGggZD0iTSAxMjMuMzUgMzcuNSBMIDEzMi4zNSAzMyBMIDEzMC4xIDM3LjUgTCAxMzIuMzUgNDIgWiIgZmlsbD0iIzNhN2U4NiIgc3Ryb2tlPSIjM2E3ZTg2IiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxwYXRoIGQ9Ik0gNjAwIDE1Ni42NSBMIDU5NS41IDE0Ny42NSBMIDYwMCAxNDkuOSBMIDYwNC41IDE0Ny42NSBaIiBmaWxsPSIjM2E3ZTg2IiBzdHJva2U9IiMzYTdlODYiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxwYXRoIGQ9Ik0gMTIwIDExMi41IEwgMzQwIDExMi41IEwgMzQwIDE1My42MyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDA5OTAwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiIHN0cm9rZS1kYXNoYXJyYXk9IjgiIHN0eWxlPSJhbmltYXRpb246IDUwMG1zIGxpbmVhciAwcyBpbmZpbml0ZSBub3JtYWwgbm9uZSBydW5uaW5nIGdlLWZsb3ctYW5pbWF0aW9uLTNBNHIyVmhzclJtdzN1SURUTGFoOyBzdHJva2UtZGFzaG9mZnNldDogMTZweDsiLz48cGF0aCBkPSJNIDM0MCAxNTguODggTCAzMzYuNSAxNTEuODggTCAzNDAgMTUzLjYzIEwgMzQzLjUgMTUxLjg4IFoiIGZpbGw9IiMwMDk5MDAiIHN0cm9rZT0iIzAwOTkwMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTAxcHg7IG1hcmdpbi1sZWZ0OiAxNjVweDsiPjxkaXYgc3R5bGU9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjMDA5OTAwOyBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7ICI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDExcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMCwgMTUzLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyB3aGl0ZS1zcGFjZTogbm93cmFwOyI+U0NMPC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjE2NSIgeT0iMTA0IiBmaWxsPSIjMDA5OTAwIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjExcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlNDTDwvdGV4dD48L3N3aXRjaD48L2c+PC9nPjxnPjxwYXRoIGQ9Ik0gMTIwIDExMi41IEwgNDgwIDExMi41IEwgNDgwIDE1My42MyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDA5OTAwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiIHN0cm9rZS1kYXNoYXJyYXk9IjgiIHN0eWxlPSJhbmltYXRpb246IDUwMG1zIGxpbmVhciAwcyBpbmZpbml0ZSBub3JtYWwgbm9uZSBydW5uaW5nIGdlLWZsb3ctYW5pbWF0aW9uLTNBNHIyVmhzclJtdzN1SURUTGFoOyBzdHJva2UtZGFzaG9mZnNldDogMTZweDsiLz48cGF0aCBkPSJNIDQ4MCAxNTguODggTCA0NzYuNSAxNTEuODggTCA0ODAgMTUzLjYzIEwgNDgzLjUgMTUxLjg4IFoiIGZpbGw9IiMwMDk5MDAiIHN0cm9rZT0iIzAwOTkwMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxwYXRoIGQ9Ik0gMTIwIDExMi41IEwgNjYwIDExMi41IEwgNjYwIDE1My42MyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDA5OTAwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiIHN0cm9rZS1kYXNoYXJyYXk9IjgiIHN0eWxlPSJhbmltYXRpb246IDUwMG1zIGxpbmVhciAwcyBpbmZpbml0ZSBub3JtYWwgbm9uZSBydW5uaW5nIGdlLWZsb3ctYW5pbWF0aW9uLTNBNHIyVmhzclJtdzN1SURUTGFoOyBzdHJva2UtZGFzaG9mZnNldDogMTZweDsiLz48cGF0aCBkPSJNIDY2MCAxNTguODggTCA2NTYuNSAxNTEuODggTCA2NjAgMTUzLjYzIEwgNjYzLjUgMTUxLjg4IFoiIGZpbGw9IiMwMDk5MDAiIHN0cm9rZT0iIzAwOTkwMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMjAiIGhlaWdodD0iMTUwIiByeD0iMTgiIHJ5PSIxOCIgZmlsbD0iI2ZmY2M5OSIgc3Ryb2tlPSIjMzYzOTNkIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAxMThweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiA3NXB4OyBtYXJnaW4tbGVmdDogMXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6IHJnYigwLCAwLCAwKTsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgb3ZlcmZsb3ctd3JhcDogbm9ybWFsOyI+Q29udHJvbGxlcjwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI2MCIgeT0iNzkiIGZpbGw9InJnYigwLCAwLCAwKSIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIxMnB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5Db250cm9sbGVyPC90ZXh0Pjwvc3dpdGNoPjwvZz48L2c+PGc+PHJlY3QgeD0iMzkwIiB5PSIxNjAiIHdpZHRoPSIxMjAiIGhlaWdodD0iNjAiIHJ4PSI5IiByeT0iOSIgZmlsbD0iI2IwZTNlNiIgc3Ryb2tlPSIjMGU4MDg4IiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAxMThweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAxOTBweDsgbWFyZ2luLWxlZnQ6IDM5MXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6IHJnYigwLCAwLCAwKTsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgb3ZlcmZsb3ctd3JhcDogbm9ybWFsOyI+PGRpdj5UYXJnZXQ8L2Rpdj5AMHgxMjwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI0NTAiIHk9IjE5NCIgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEycHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlRhcmdldEAweDEyPC90ZXh0Pjwvc3dpdGNoPjwvZz48L2c+PGc+PHJlY3QgeD0iMjUwIiB5PSIxNjAiIHdpZHRoPSIxMjAiIGhlaWdodD0iNjAiIHJ4PSI5IiByeT0iOSIgZmlsbD0iI2IwZTNlNiIgc3Ryb2tlPSIjMGU4MDg4IiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAxMThweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAxOTBweDsgbWFyZ2luLWxlZnQ6IDI1MXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6IHJnYigwLCAwLCAwKTsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgb3ZlcmZsb3ctd3JhcDogbm9ybWFsOyI+PGRpdj5UYXJnZXQ8L2Rpdj5AMHgxNzwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSIzMTAiIHk9IjE5NCIgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEycHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlRhcmdldEAweDE3PC90ZXh0Pjwvc3dpdGNoPjwvZz48L2c+PGc+PHJlY3QgeD0iNTcwIiB5PSIxNjAiIHdpZHRoPSIxMjAiIGhlaWdodD0iNjAiIHJ4PSI5IiByeT0iOSIgZmlsbD0iI2IwZTNlNiIgc3Ryb2tlPSIjMGU4MDg4IiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxnPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAxMThweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAxOTBweDsgbWFyZ2luLWxlZnQ6IDU3MXB4OyI+PGRpdiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6IHJnYigwLCAwLCAwKTsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgb3ZlcmZsb3ctd3JhcDogbm9ybWFsOyI+PGRpdj5UYXJnZXQ8L2Rpdj5AMHg1ZTwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI2MzAiIHk9IjE5NCIgZmlsbD0icmdiKDAsIDAsIDApIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjEycHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlRhcmdldEAweDVlPC90ZXh0Pjwvc3dpdGNoPjwvZz48L2c+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vd3d3LmRyYXdpby5jb20vZG9jL2ZhcS9zdmctZXhwb3J0LXRleHQtcHJvYmxlbXMiIHRhcmdldD0iX2JsYW5rIj48dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjEwcHgiIHg9IjUwJSIgeT0iMTAwJSI+VGV4dCBpcyBub3QgU1ZHIC0gY2Fubm90IGRpc3BsYXk8L3RleHQ+PC9hPjwvc3dpdGNoPjwvc3ZnPg=="},68621:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/i2c_7bit_address_transmission-dbcbcdc041a2fb9a7dcab8310750970d.svg"},70258:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"embedded/Embassy/index","title":"Embassy","description":"Embassy is a modern, async embedded framework for Rust. It provides efficient, non-blocking abstractions for microcontrollers.","source":"@site/docs/embedded/1.Embassy/index.md","sourceDirName":"embedded/1.Embassy","slug":"/embedded/Embassy/","permalink":"/docs/embedded/Embassy/","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/embedded/1.Embassy/index.md","tags":[],"version":"current","frontMatter":{"title":"Embassy","position":1},"sidebar":"tutorialSidebar","previous":{"title":"Tock","permalink":"/docs/embedded/Tock/"},"next":{"title":"Introduction","permalink":"/docs/desktop_applications/Overview/Introduction"}}');var s=i(74848),a=i(28453);const d={title:"Embassy",position:1},r="Introduction",l={},c=[{value:"Environment setup",id:"environment-setup",level:2},{value:"Blink an LED",id:"blink-an-led",level:2},{value:"3-bit Counter",id:"3-bit-counter",level:3},{value:"Improved <code>BinaryCounter</code>",id:"improved-binarycounter",level:3},{value:"I2C",id:"i2c",level:3},{value:"Configuration",id:"configuration",level:4},{value:"Data transmission",id:"data-transmission",level:4},{value:"Initiation",id:"initiation",level:5},{value:"Transmission",id:"transmission",level:5},{value:"End",id:"end",level:5},{value:"I2C in Embassy",id:"i2c-in-embassy",level:4},{value:"Reading from a target",id:"reading-from-a-target",level:4},{value:"Writing to a target",id:"writing-to-a-target",level:4},{value:"AT24C256 EEPROM",id:"at24c256-eeprom",level:3},{value:"Device Addressing",id:"device-addressing",level:4},{value:"Memory Organization",id:"memory-organization",level:4},{value:"Reading from the AT24C256",id:"reading-from-the-at24c256",level:5},{value:"Writing to the AT24C256",id:"writing-to-the-at24c256",level:5},{value:"<code>eeprom24x</code> crate",id:"eeprom24x-crate",level:4}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/embassy-rs/embassy",children:"Embassy"})," is a modern, ",(0,s.jsx)(n.code,{children:"async"})," embedded framework for Rust. It provides efficient, non-blocking abstractions for microcontrollers."]}),"\n",(0,s.jsxs)(n.p,{children:["First, clone the ",(0,s.jsx)(n.code,{children:"embassy-rs"})," repository."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"git clone git@github.com:embassy-rs/embassy.git\ncd embassy\n"})}),"\n",(0,s.jsx)(n.h2,{id:"environment-setup",children:"Environment setup"}),"\n",(0,s.jsxs)(n.p,{children:["For those of you working in Visual Studio Code, the Embassy project has support for ",(0,s.jsx)(n.code,{children:"rust-analyzer"}),". In order to properly set it up, make sure you correctly open the project's root folder (",(0,s.jsx)(n.code,{children:"embassy"}),"), and modify the workspace settings according to the example bellow."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title=".vscode/settings.json"',children:'{\n  // ...\n\n  // Uncomment the target of your chip.\n\n  // highlight-start\n  //"rust-analyzer.cargo.target": "thumbv6m-none-eabi",\n  "rust-analyzer.cargo.target": "thumbv7m-none-eabi",\n  //highlight-end\n  // "rust-analyzer.cargo.target": "thumbv7em-none-eabi",\n  //"rust-analyzer.cargo.target": "thumbv7em-none-eabihf",\n  //"rust-analyzer.cargo.target": "thumbv8m.main-none-eabihf",\n  "rust-analyzer.cargo.features": [\n    // Comment these features\n    // highlight-start\n    // "stm32f446re",\n    // "time-driver-any",\n    // "unstable-pac",\n    // "exti",\n    // "rt",\n    // highlight-end\n  ],\n  "rust-analyzer.linkedProjects": [\n    // highlight-next-line\n    "examples/stm32f4/Cargo.toml",\n    // To work on the examples, comment the line above and all of the cargo.features lines,\n    // then uncomment ONE line below to select the chip you want to work on.\n    // This makes rust-analyzer work on the example crate and all its dependencies.\n    // "examples/mspm0c1104/Cargo.toml",\n    // "examples/mspm0g3507/Cargo.toml",\n    // ...\n  ],\n}\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"blink-an-led",children:"Blink an LED"}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, Embassy provides a variety of examples implemented for a multitude of hardware platforms, our ",(0,s.jsx)(n.strong,{children:"STM32F429ZI"})," included. Examples for our board can be found in the ",(0,s.jsx)(n.code,{children:"examples/stm32f4"})," crate. Multiple examples can be found in the ",(0,s.jsx)(n.code,{children:"src"})," folder, organized as separate ",(0,s.jsx)(n.em,{children:"binaries"}),". To flash one of the examples, simply run:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"cd examples/stm32f4\ncargo run --bin <EXAMPLE>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Go ahead and run the ",(0,s.jsx)(n.code,{children:"blinky"})," example. You should get an output similar to this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"cargo run --bin blinky\n    Compiling proc-macro2 v1.0.97\n    Compiling unicode-ident v1.0.18\n    ...\n    Compiling embassy-net v0.7.0 (/Users/danut/Work/eurotock/ipw-repos/embassy/embassy-net)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 12.33s\n     Running `probe-rs run --chip STM32F429ZITx target/thumbv7em-none-eabi/debug/blinky`\n      Erasing \u2714 100% [####################] 128.00 KiB @  44.41 KiB/s (took 3s)\n  Programming \u2714 100% [####################]  81.00 KiB @  31.50 KiB/s (took 3s)                         Finished in 5.46s\n0.000000 [TRACE] BDCR ok: 00008200 (embassy_stm32 src/rcc/bd.rs:221)\n0.000000 [DEBUG] flash: latency=0 (embassy_stm32 src/rcc/f247.rs:264)\n0.000000 [DEBUG] rcc: Clocks { hclk1: MaybeHertz(16000000), hclk2: MaybeHertz(16000000), hclk3: MaybeHertz(16000000), hse: MaybeHertz(0), lse: MaybeHertz(0), lsi: MaybeHertz(0), pclk1: MaybeHertz(16000000), pclk1_tim: MaybeHertz(16000000), pclk2: MaybeHertz(16000000), pclk2_tim: MaybeHertz(16000000), pll1_q: MaybeHertz(0), plli2s1_p: MaybeHertz(0), plli2s1_q: MaybeHertz(0), plli2s1_r: MaybeHertz(0), pllsai1_q: MaybeHertz(0), rtc: MaybeHertz(32000), sys: MaybeHertz(16000000) } (embassy_stm32 src/rcc/mod.rs:71)\n0.000152 [INFO ] Hello World! (blinky src/bin/blinky.rs:13)\n0.000915 [INFO ] high (blinky src/bin/blinky.rs:18)\n0.302062 [INFO ] low (blinky src/bin/blinky.rs:22)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-bit-counter",children:"3-bit Counter"}),"\n",(0,s.jsxs)(n.p,{children:["For this task, you will have to implement a 3-bit counter, using the 3 on-board LEDs and the ",(0,s.jsx)(n.code,{children:"USER"})," button on board."]}),"\n",(0,s.jsxs)(n.p,{children:["You will need to create a new binary in the ",(0,s.jsx)(n.code,{children:"src/bin"})," folder you can name ",(0,s.jsx)(n.code,{children:"counter-3bit.rs"}),", starting from the ",(0,s.jsx)(n.code,{children:"blinky.rs"})," example."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/bin/counter-3bit.rs.rs"',children:'#![no_std]\n#![no_main]\n\nuse defmt::*;\nuse embassy_executor::Spawner;\nuse embassy_stm32::gpio::{Level, Output, Speed};\nuse embassy_time::Timer;\nuse {defmt_rtt as _, panic_probe as _};\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let p = embassy_stm32::init(Default::default());\n    info!("Hello World!");\n\n    let mut led = Output::new(p.PB7, Level::High, Speed::Low);\n\n    loop {\n        info!("high");\n        led.set_high();\n        Timer::after_millis(300).await;\n\n        info!("low");\n        led.set_low();\n        Timer::after_millis(300).await;\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The first step is figuring out the pins the other two LEDs are connected to. To do so, you can consult the board's ",(0,s.jsx)(n.a,{href:"https://www.st.com/resource/en/user_manual/um1974-stm32-nucleo144-boards-mb1137-stmicroelectronics.pdf",children:"User Manual"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/bin/counter-3bit.rs.rs"',children:'#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let p = embassy_stm32::init(Default::default());\n    info!("Hello World!");\n\n    let mut led0 = todo!("Replace me");\n    let mut led1 = Output::new(p.PB7, Level::High, Speed::Low);\n    let mut led2 = todo!("Replace me");\n\n    loop {\n        // ...\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Next, you will have to instantiate the button. We will want to use one of the external interrupt lines, in order to use the asynchronous methods for the user button."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let button = ExtiInput::new(p.PC13, p.EXTI13, Pull::Down);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Make sure to fix all the import errors."}),"\n",(0,s.jsxs)(n.p,{children:["Now, inside the main ",(0,s.jsx)(n.code,{children:"loop"}),". Await for the button to be pressed in order to update the ",(0,s.jsx)(n.em,{children:'"3-bit display"'}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/bin/counter-3bit.rs.rs"',children:"let mut counter = 0;\nloop {\n    button.wait_for_high().await;\n    counter = (counter + 1) % 7;\n\n    // Depending on the value of each of the three bits,\n    // set the LEDs high or low\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"improved-binarycounter",children:["Improved ",(0,s.jsx)(n.code,{children:"BinaryCounter"})]}),"\n",(0,s.jsxs)(n.p,{children:["With everything in place, here comes the question of extending the functionalities. We would like for this display mechanism to be painlessly extensible to work with any number of LEDs. The quick and painless answer to this problem is generics. We must define a generic ",(0,s.jsx)(n.code,{children:"BinaryCounter"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/bin/binary-counter.rs"',children:"struct BinaryCounter<'a, const N: usize> {\n    inner_counter: usize,\n    leds: [Output<'a>; N],\n}\n\nimpl<'a, const N: usize> BinaryCounter<'a, N> {\n    fn new(leds: [Output<'a>; N]) -> Self {\n        Self {\n            inner_counter: 0,\n            leds,\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, we will define the API for interacting with our display. We will have two methods, ",(0,s.jsx)(n.code,{children:"increment"})," which will increase the inner counter's value by one unit and ",(0,s.jsx)(n.code,{children:"display"}),", which will update the LEDs state."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/bin/binary-counter.rs"',children:"impl<'a, const N: usize> BinaryCounter<'a, N> {\n    fn new(leds: [Output<'a>; N]) -> Self {\n        Self {\n            inner_counter: 0,\n            leds,\n        }\n    }\n\n    /// This function increases the inner counter\n    fn increment(&mut self) {\n        core::todo!()\n    }\n\n    /// This function updates the state of the LEDs\n    /// according to the `inner_counter` value\n    fn display(&mut self) {\n        core::todo!()\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["With the interface in place, we can write the ",(0,s.jsx)(n.code,{children:"main"})," function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/bin/binary-counter.rs"',children:'#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let p = embassy_stm32::init(Default::default());\n    info!("Binary Demo!");\n\n    // TODO: `Output` definition\n\n    let mut bc = BinaryCounter::new([led0, led1, led2]);\n\n    let mut button = ExtiInput::new(p.PC13, p.EXTI13, Pull::Down);\n\n    loop {\n        bc.display();\n        button.wait_for_high().await;\n        bc.increment();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"i2c",children:"I2C"}),"\n",(0,s.jsxs)(n.p,{children:["The Inter-Integrated Circuit (I2C) is a synchronous, multi-controller/multi-target communication protocol. Similarly to the SPI, it allows data transfer between a controller and one or more peripheral ICs, but it uses only 2 wires (1 data line and 1 clock line, making it half-duplex) and has a different way of addressing the peripherals: using their unique ",(0,s.jsx)(n.em,{children:"addresses"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"I2C_protocol",src:i(36507).A+"",width:"691",height:"221"})}),"\n",(0,s.jsx)(n.p,{children:"I2C transmission uses 2 lines:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SCL"})," - ",(0,s.jsx)(n.strong,{children:"S"}),"erial ",(0,s.jsx)(n.strong,{children:"CL"}),"ock line - clock is generated by the controller - used to synchronize communication between the controller and the targets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SDA"})," - ",(0,s.jsx)(n.strong,{children:"S"}),"erial ",(0,s.jsx)(n.strong,{children:"DA"}),"ta line - carries data between the controller and the addressed target","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["targets read data from SDA ",(0,s.jsx)(n.strong,{children:"only"})," when the clock is ",(0,s.jsx)(n.em,{children:"low"})]}),"\n",(0,s.jsxs)(n.li,{children:["targets write data to SDA ",(0,s.jsx)(n.strong,{children:"only"})," when the clock is ",(0,s.jsx)(n.em,{children:"high"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Half duplex",type:"info",children:(0,s.jsxs)(n.p,{children:["The communication is ",(0,s.jsx)(n.em,{children:"half-duplex"}),". This means that data is transmitted only in one direction at a time, since there is only ",(0,s.jsx)(n.em,{children:"one"})," data line that can be used both for sending data to the target and receiving data from the target."]})}),"\n",(0,s.jsxs)(n.admonition,{title:"I2C inner works",type:"info",children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SDA"})," and ",(0,s.jsx)(n.code,{children:"SCL"})," wires are never actually driven (set to ",(0,s.jsx)(n.code,{children:"LOW"}),"/",(0,s.jsx)(n.code,{children:"HIGH"}),") by the controller/peripherals. The line is controlled by either pulling the line low or releasing the line high."]}),(0,s.jsxs)(n.p,{children:["When the line is ",(0,s.jsx)(n.em,{children:"pulled down"}),", this means that it is connected directly to ",(0,s.jsx)(n.code,{children:"GND"}),". This electronically translates to ",(0,s.jsx)(n.code,{children:"LOW"}),"."]}),(0,s.jsxs)(n.p,{children:["When the line is ",(0,s.jsx)(n.em,{children:"released"}),", or ",(0,s.jsx)(n.em,{children:"pulled up"}),", this means that it connects back to ",(0,s.jsx)(n.code,{children:"3V3"}),' (which we can consider as being the "default" state of the wire) through a pull-up resistor. This electronically translates to ',(0,s.jsx)(n.code,{children:"HIGH"}),"."]}),(0,s.jsxs)(n.p,{children:["This is called ",(0,s.jsx)(n.em,{children:"open-drain connection"}),". You can read more about how it works ",(0,s.jsx)(n.a,{href:"https://www.ti.com/lit/an/sbaa565/sbaa565.pdf?ts=1712891793335#:~:text=I2C%20is%20a%20two%2Dwire,and%20receive%20commands%20and%20data.",children:"here"}),", at section 2.2."]})]}),"\n",(0,s.jsx)(n.h4,{id:"data-transmission",children:"Data transmission"}),"\n",(0,s.jsxs)(n.p,{children:["Each target is associated with a unique ",(0,s.jsx)(n.em,{children:"address"}),". The controller uses this address to initiate communication with that target. This address can either be 7 or 10 bits."]}),"\n",(0,s.jsx)(n.h5,{id:"initiation",children:"Initiation"}),"\n",(0,s.jsxs)(n.p,{children:["Before the transmission, both the ",(0,s.jsx)(n.code,{children:"SCL"})," and ",(0,s.jsx)(n.code,{children:"SDA"})," lines are set to ",(0,s.jsx)(n.code,{children:"HIGH"}),". First thing the controller does is to signal a ",(0,s.jsx)(n.code,{children:"start"})," condition by pulling the ",(0,s.jsx)(n.code,{children:"SDA"})," line to ",(0,s.jsx)(n.code,{children:"LOW"}),". All targets understand that the communication is about to commence and listen on the ",(0,s.jsx)(n.code,{children:"SDA"})," line. Next, the controller starts the clock and begins to write the address of the target it wants to talk to, followed by a command bit that signifies whether the controller wants to ",(0,s.jsx)(n.em,{children:"read"})," from the target or ",(0,s.jsx)(n.em,{children:"write"})," to it. Whichever target recognizes its address, responds with an ",(0,s.jsx)(n.code,{children:"ACK"})," (acknowledged), by pulling the ",(0,s.jsx)(n.code,{children:"SDA"})," to ",(0,s.jsx)(n.code,{children:"LOW"}),". If no target responds and the ",(0,s.jsx)(n.code,{children:"SDA"})," stays ",(0,s.jsx)(n.code,{children:"HIGH"}),", then it is considered a ",(0,s.jsx)(n.code,{children:"NACK"})," (not acknowledged). Afterwards, the data transmission can begin."]}),"\n",(0,s.jsx)(n.h5,{id:"transmission",children:"Transmission"}),"\n",(0,s.jsxs)(n.p,{children:["Depending on the command bit (R/W), either the controller or the target begins to send data over the ",(0,s.jsx)(n.code,{children:"SDA"})," line. Data is sent one byte at a time, and then acknowledged by the receiver. One sequence of a data byte and ",(0,s.jsx)(n.code,{children:"ack"})," is called a ",(0,s.jsx)(n.em,{children:"frame"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"During the communication, data can be:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["written to the ",(0,s.jsx)(n.code,{children:"SDA"})," line ",(0,s.jsx)(n.em,{children:"only"})," when ",(0,s.jsx)(n.code,{children:"SCL"})," is ",(0,s.jsx)(n.code,{children:"LOW"})," or"]}),"\n",(0,s.jsxs)(n.li,{children:["read from the ",(0,s.jsx)(n.code,{children:"SDA"})," line ",(0,s.jsx)(n.em,{children:"only"})," when ",(0,s.jsx)(n.code,{children:"SCL"})," is ",(0,s.jsx)(n.code,{children:"HIGH"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"end",children:"End"}),"\n",(0,s.jsxs)(n.p,{children:["To end the transmission, the controller signals a ",(0,s.jsx)(n.code,{children:"stop"})," condition. This is done by releasing the ",(0,s.jsx)(n.code,{children:"SCL"})," line to ",(0,s.jsx)(n.code,{children:"HIGH"}),", and then also releasing the ",(0,s.jsx)(n.code,{children:"SDA"})," line. Since data can be written ",(0,s.jsx)(n.em,{children:"only"})," when ",(0,s.jsx)(n.code,{children:"SCL"})," is ",(0,s.jsx)(n.code,{children:"LOW"}),", the target understands that this is a special event, that means that the communication has ended."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"i2c_transmission",src:i(68621).A+"",width:"810",height:"90"})}),"\n",(0,s.jsxs)(n.admonition,{title:"10-bit addresses",type:"note",children:[(0,s.jsxs)(n.p,{children:["For 10-bit addresses, the controller first issues a specific sequence of bits. This sequence is reserved, therefore targets with 7-bit addresses are prohibited from having addresses that start with this sequence. These bits mark the fact that the controller is attempting to initiate communication with a target with a 10-bit address, so all 7-bit targets ignore the ",(0,s.jsx)(n.code,{children:"SDA"})," line once they recognize this sequence. After the special sequence, the controller sends the upper 2 bits of the address and the command bit, then waits for an ",(0,s.jsx)(n.code,{children:"ack"})," from the target(s) that have an address that begins with these 2 bits. Afterwards, it sends the rest of the address, and waits for an acknowledgement from the target."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"i2c_transmission_10_bit",src:i(11739).A+"",width:"1160",height:"90"})})]}),"\n",(0,s.jsx)(n.h4,{id:"i2c-in-embassy",children:"I2C in Embassy"}),"\n",(0,s.jsxs)(n.p,{children:["These are the I2C imports we will be using. We will use the functions provided by the ",(0,s.jsx)(n.code,{children:"embedded_hal_async"})," crate, since these are standard and used by most frameworks."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use embassy_stm32::i2c::I2c;\nuse embassy_stm32::{bind_interrupts, i2c, peripherals};\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:[(0,s.jsx)(n.code,{children:"I2c"})," trait importing"]}),(0,s.jsxs)(n.p,{children:["We use ",(0,s.jsx)(n.code,{children:"I2c as _"})," from ",(0,s.jsx)(n.code,{children:"embedded_hal_async"})," because in order to use the trait methods, we need to import it."]})]}),"\n",(0,s.jsx)(n.p,{children:"We start by initializing the peripherals."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let peripherals = embassy_stm32::init(Default::default());\n"})}),"\n",(0,s.jsx)(n.p,{children:"Next, we declare the pins we will be using for the SDA and SCL lines. We can find which pins of the Raspberry Pi Pico have these functions by looking at the pinout."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let sda = peripherals.PIN_X;\nlet scl = peripherals.PIN_Y;\n"})}),"\n",(0,s.jsx)(n.p,{children:"We then initialize our I2C instance, using the pins we defined earlier and a default configuration. It's recommended to use the asynchronous version, since it won't block the executor."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// I2C\nlet mut i2c = I2c::new_async(peripherals.I2CX, scl, sda, Irqs, peripherals.DMAX_CHX, peripherals.DMAX_CHX, Default::default());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The first argument of the ",(0,s.jsx)(n.code,{children:"new"})," function is the I2C channel that will be used. Each has multiple sets of pins that can be used for and you can find them marked in blue on the pinout diagram."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Irqs"})," variable refers to the interrupt that the I2C driver will use when handling transfers. We also need to bind this interrupt, which depends on the I2C channel we are working with."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"bind_interrupts!(struct Irqs {\n    I2C1_EV => i2c::EventInterruptHandler<peripherals::I2C1>;\n    I2C1_ER => i2c::ErrorInterruptHandler<peripherals::I2C1>;\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:[(0,s.jsx)(n.code,{children:"I2cConfig"})," and ",(0,s.jsx)(n.code,{children:"I2cInterruptHandler"})," are renamed imports"]}),(0,s.jsxs)(n.p,{children:["Because of the Embassy project naming convention, multiple ",(0,s.jsx)(n.code,{children:"Config"}),"s and ",(0,s.jsx)(n.code,{children:"InterruptHandler"}),"s can exist in one file. To solve this without having to prefix them with their respective module in code every time we use them (i.e use ",(0,s.jsx)(n.code,{children:"i2c::Config"})," and ",(0,s.jsx)(n.code,{children:"i2c::InterruptHandler"}),"), in the code examples above ",(0,s.jsx)(n.code,{children:"I2cConfig"})," and ",(0,s.jsx)(n.code,{children:"I2CInterruptHandler"})," are renamed imports:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use embassy_stm32::i2c::{I2c, InterruptHandler as I2CInterruptHandler, Config as I2cConfig};\n"})})]}),"\n",(0,s.jsx)(n.h4,{id:"reading-from-a-target",children:"Reading from a target"}),"\n",(0,s.jsxs)(n.p,{children:["To read from a target, we will be using the ",(0,s.jsx)(n.code,{children:"read"})," ",(0,s.jsx)(n.strong,{children:"async"})," function of the I2C driver."]}),"\n",(0,s.jsx)(n.p,{children:"The function takes 2 parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the address of the target we are attempting to receive the data from"}),"\n",(0,s.jsxs)(n.li,{children:["the ",(0,s.jsx)(n.em,{children:"receiving"})," buffer in which we will store the data received from the target"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The following example reads two bytes from the target of address ",(0,s.jsx)(n.code,{children:"0x44"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"const TARGET_ADDR: u16 = 0x44;\nlet mut rx_buf = [0x00u8; 2];\ni2c.read(TARGET_ADDR, &mut rx_buf).await.unwrap();\n"})}),"\n",(0,s.jsx)(n.h4,{id:"writing-to-a-target",children:"Writing to a target"}),"\n",(0,s.jsxs)(n.p,{children:["To write data to a target, we will be using the ",(0,s.jsx)(n.code,{children:"write"})," ",(0,s.jsx)(n.strong,{children:"async"})," function of the I2C driver."]}),"\n",(0,s.jsx)(n.p,{children:"This function also takes 2 parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the address of the target we are attempting to transmit the data to"}),"\n",(0,s.jsxs)(n.li,{children:["the ",(0,s.jsx)(n.em,{children:"transmitting"})," buffer that contains the data we want to send to the target"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The following example writes two bytes to the target of address ",(0,s.jsx)(n.code,{children:"0x44"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"const TARGET_ADDR: u16 = 0x44;\nlet tx_buf = [0x01, 0x05];\ni2c.write(TARGET_ADDR, &tx_buf).await.unwrap();\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["We can also use ",(0,s.jsx)(n.code,{children:"write_read"})," if we want to perform both a write and a read one after the other."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"i2c.write_read(TARGET_ADDR, &tx_buf, &mut rx_buf).await.unwrap();\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"at24c256-eeprom",children:"AT24C256 EEPROM"}),"\n",(0,s.jsxs)(n.p,{children:["The AT24C256 is a 256-kilobit ",(0,s.jsx)(n.strong,{children:"Electrically Erasable Programmable Read-Only Memory"})," (EEPROM) device that communicates using the I2C protocol. It is commonly used for storing non-volatile data, such as configuration settings or calibration data, which need to persist even when the device is powered off."]}),"\n",(0,s.jsx)(n.h4,{id:"device-addressing",children:"Device Addressing"}),"\n",(0,s.jsxs)(n.p,{children:["The AT24C256 uses a 7-bit I2C address, with the most significant 5 bits fixed as ",(0,s.jsx)(n.code,{children:"10100"}),". The remaining 2 bits are configurable by connecting the ",(0,s.jsx)(n.code,{children:"A1"})," and ",(0,s.jsx)(n.code,{children:"A0"})," pins to either ",(0,s.jsx)(n.code,{children:"GND"})," or ",(0,s.jsx)(n.code,{children:"VCC"}),", allowing up to 4 devices to be connected on the same I2C bus. Knowing the state of the pins, you can determine the address using the formula: ",(0,s.jsx)(n.code,{children:"0x50 | (A1 << 1) | A0"}),". To determine the address of the EEPROM used by our board, you can check the ",(0,s.jsx)(n.a,{href:"https://gitlab.cs.pub.ro/pmrust/pm-ma-pcb/-/blob/main/Schematic/MA.pdf?ref_type=heads",children:"schematic"})," or perform an I2C scan."]}),"\n",(0,s.jsx)(n.h4,{id:"memory-organization",children:"Memory Organization"}),"\n",(0,s.jsx)(n.p,{children:"The memory is organized into 32,768 bytes, divided into 512 pages of 64 bytes each. Each byte can be accessed individually, or multiple bytes can be written/read in a single operation using page addressing."}),"\n",(0,s.jsx)(n.h5,{id:"reading-from-the-at24c256",children:"Reading from the AT24C256"}),"\n",(0,s.jsxs)(n.p,{children:["To read data from the EEPROM, you first need to write the memory address you want to read, then read the byte at that memory location. Because we are working with 32,768 bytes of memory (which is 2",(0,s.jsx)("sup",{children:"15"})," bytes), we are working about 2-byte addresses that need to be sent ",(0,s.jsx)(n.strong,{children:"High byte"})," first (big endian)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let mem_addr: u16 = 0xCAFE; // 16 bit address\nlet memory_address: [u8; 2] = mem_addr.to_be_bytes(); // `be` stands for big endian\nlet mut data: [u8; 1] = [0];\n\ni2c.write_read(EEPROM_ADDR, &memory_address, &mut data).await.unwrap();\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Sequential read",type:"note",children:[(0,s.jsxs)(n.p,{children:["The AT24C256 supports sequential reads. After the EEPROM sends a data word (byte), if the microcontroller sends a responds with an ",(0,s.jsx)(n.strong,{children:"ACK"})," instead of a ",(0,s.jsx)(n.strong,{children:"Stop Condition"})," the memory will continue to increment the internal data word address and serially clock out sequential data words. When the memory address limit is reached, the data word address will ",(0,s.jsx)(n.em,{children:'"roll over"'})," (begin writing from the beginning) and the sequential read will continue."]}),(0,s.jsx)(n.p,{children:"This means that we can read multiple consecutive bytes:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let mem_addr: u16 = 0xBABE; // 16 bit address\nlet mem_buff: [u8; 2] = mem_addr.to_be_bytes(); // `be` stands for big endian\nlet mut data: [u8; 10] = [0; 10];\n\ni2c.write_read(EEPROM_ADDR, &mem_buff, &mut data).await.unwrap();\n"})})]}),"\n",(0,s.jsx)(n.h5,{id:"writing-to-the-at24c256",children:"Writing to the AT24C256"}),"\n",(0,s.jsxs)(n.p,{children:["The EEPROM supports the writing of up to 64 bytes (one page) in a single transaction. The microcontroller performs a write transaction where the first two bytes are the 16-bit memory location in big endian format, followed by a number of bytes that should be written, starting from that respective address. The particularity of this memory module is that, for a write within a ",(0,s.jsx)(n.strong,{children:"page"})," when reaching the upper page boundary, the internal data word address would do a ",(0,s.jsx)(n.em,{children:'"roll over"'})," to the address of the first byte of the same page."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let mem_addr: u16 = 0xBABE; // 16 bit address\nlet mem_buff: [u8; 2] = mem_addr.to_be_bytes(); // `be` stands for big endian\nlet data: [u8; 8] = [0xCA, 0xFE, 0xBA, 0xBE, 0xDE, 0xAD, 0xBE, 0xEF];\n\nlet mut tx_buf = [0x00; 8 + 2];\ntx_buf[..2].copy_from_slice(&mem_buff);\ntx_buf[2..].copy_from_slice(&data);\n\ni2c.write(EEPROM_ADDR, &tx_buf).await.unwrap();\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Write delay",type:"danger",children:(0,s.jsxs)(n.p,{children:["After each complete memory write transaction, the EEPROM an internally-timed write cycle of roughly ",(0,s.jsx)(n.strong,{children:"5ms"}),". If you have to perform a series of consecutive writes, make sure to space them out appropriately."]})}),"\n",(0,s.jsxs)(n.h4,{id:"eeprom24x-crate",children:[(0,s.jsx)(n.code,{children:"eeprom24x"})," crate"]}),"\n",(0,s.jsxs)(n.p,{children:["To simplify the interfacing with the non-volatile memory for your ",(0,s.jsx)(n.strong,{children:"project"}),", you can use the ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/eeprom24x",children:(0,s.jsx)(n.code,{children:"eeprom24x"})})," crate. It is a is a platform agnostic Rust driver for the 24x series serial EEPROM, based on the ",(0,s.jsx)(n.a,{href:"https://docs.rs/embedded-hal/1.0.0/embedded_hal/",children:(0,s.jsx)(n.code,{children:"embedded-hal"})})," traits. This means that you will not be able to harness the power of the async executor, and you will need to use the conventional ",(0,s.jsx)(n.strong,{children:"blocking"})," API."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);