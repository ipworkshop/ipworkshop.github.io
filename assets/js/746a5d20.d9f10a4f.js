"use strict";(self.webpackChunkcourses=self.webpackChunkcourses||[]).push([[1600],{10122:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"desktop_applications/Rust/Pattern-matching","title":"Pattern Matching","description":"---","source":"@site/docs/desktop_applications/02_Rust/07_Pattern-matching.md","sourceDirName":"desktop_applications/02_Rust","slug":"/desktop_applications/Rust/Pattern-matching","permalink":"/docs/desktop_applications/Rust/Pattern-matching","draft":false,"unlisted":false,"editUrl":"https://github.com/ipworkshop/ipworkshop.github.io/edit/main/docs/desktop_applications/02_Rust/07_Pattern-matching.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Pattern Matching"},"sidebar":"tutorialSidebar","previous":{"title":"References-and-slices","permalink":"/docs/desktop_applications/Rust/References-and-slices"},"next":{"title":"Structs and Enums","permalink":"/docs/desktop_applications/Rust/Structs-and-enums"}}');var i=t(74848),r=t(28453);const a={title:"Pattern Matching"},o=void 0,c={},l=[{value:"Advanced Pattern Matching: The <code>match</code> Expression (10 min)",id:"advanced-pattern-matching-the-match-expression-10-min",level:3}];function h(e){const n={code:"code",em:"em",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"advanced-pattern-matching-the-match-expression-10-min",children:["Advanced Pattern Matching: The ",(0,i.jsx)(n.code,{children:"match"})," Expression (10 min)"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"match"})," expression is one of Rust's most powerful control flow constructs. It allows you to compare a value against a series of patterns and then execute code based on which pattern matches. It's often a more robust and readable alternative to long ",(0,i.jsx)(n.code,{children:"if-else if"})," chains."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exhaustiveness:"})," A key feature of ",(0,i.jsx)(n.code,{children:"match"})," is that it must be ",(0,i.jsx)(n.strong,{children:"exhaustive"}),". This means you have to cover ",(0,i.jsx)(n.em,{children:"every possible value"})," that the data could take. If you don't, Rust's compiler will give you an error, which helps prevent bugs!"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's look at a simple example with numbers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    let number = 3;\n\n    match number { // Match the \'number\' against these patterns\n        1 => println!("One!"), // If number is 1, do this\n        2 => println!("Two!"), // If number is 2, do this\n        3 | 4 => println!("Three or Four!"), // If number is 3 OR 4, do this (multiple patterns)\n        5..=10 => println!("Between 5 and 10, inclusive!"), // If number is in this range\n        _ => println!("Something else!"), // The underscore \'_\' is a catch-all pattern (like \'default\' in switch)\n    }\n\n    let result = match number { // \'match\' can also be an expression, returning a value\n        1 => "It\'s one",\n        _ => "It\'s not one", // All branches must return the same type!\n    };\n    println!("Result: {}", result);\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["When to use ",(0,i.jsx)(n.code,{children:"match"})," vs. ",(0,i.jsx)(n.code,{children:"if"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"if"})," for simple true/false conditions or a few distinct branches."]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"match"})," when you have many possible values or complex patterns to handle, especially when working with ",(0,i.jsx)(n.code,{children:"enum"}),"s (which we'll cover in Lesson 3) or ",(0,i.jsx)(n.code,{children:"Result"})," types (which you saw in Lesson 1's I/O)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);